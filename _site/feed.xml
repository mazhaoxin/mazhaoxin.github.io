<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MaZhaoxin&apos;s Blog</title>
    <description>这里是马昭鑫的博客，用来记录平时一些乱七八糟的想法和总结。Keep thinking, keep moving.
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 21 Sep 2024 08:50:36 +0000</pubDate>
    <lastBuildDate>Sat, 21 Sep 2024 08:50:36 +0000</lastBuildDate>
    <generator>Jekyll v4.2.1</generator>
    
      <item>
        <title>Flask App部署在子路径下的方法</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;之前提到，我基于Flask做了个简单的微博部署在了NAS上。如今已过了3年，当我想再加个应用时遇到了困难，因为域名只有一个，要怎么映射到多个站点上呢？如果站点的技术栈不同，有没有统一的部署方式？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;nginx&quot;&gt;Nginx&lt;/h2&gt;

&lt;p&gt;Nginx的鼎鼎大名自然早有耳闻，但一直不知道有什么用。好像每次听到这个词，都会跟“负载均衡”、“反向代理”之类的词一起出现。就像有人说过的，“人们对名字的恐惧，超过了这个名字代表的事物”。&lt;/p&gt;

&lt;p&gt;经过查询学习，了解到Nginx其实就相当于“银行网点的大堂经理”，当顾客（访问）到来时先看一下他要办什么业务，简单的业务（如图片之类的静态文件）就当场办理，复杂的业务（涉及到计算处理的）再根据业务类型分配到对应的柜台。&lt;/p&gt;

&lt;p&gt;想一下我要实现什么效果：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;基于Flask的App不需要考虑自己会部署在哪个路径下，无论是根路径（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://host/&lt;/code&gt;）还是子路径（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://host/app/&lt;/code&gt;）都可以显示正确的画面、链接；&lt;/li&gt;
  &lt;li&gt;当用户访问时，通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://host/app1/&lt;/code&gt;可以访问App1，通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://host/app2/&lt;/code&gt;可以访问App2，无论App1和App2是用什么语言、框架实现的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Nginx这个大堂经理能起到分配业务作用的前提是，App1和App2已经开好了柜台，也就是它们有各自的访问端口，如：App1部署在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://localhost:5001&lt;/code&gt;上，App2部署在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://localhost:5002&lt;/code&gt;上。&lt;/p&gt;

&lt;p&gt;接下来便是设置Nginx，制定分配规则。在安装完成后，有个自动生成的配置文件在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/nginx/sites-available/default&lt;/code&gt;，只需要在其中再添加一条规则即可。&lt;/p&gt;

&lt;div class=&quot;language-nginx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;/app1/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kn&quot;&gt;proxy_pass&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;http://127.0.0.1:5001/app1/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kn&quot;&gt;proxy_redirect&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;off&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;kn&quot;&gt;proxy_set_header&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Host&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kn&quot;&gt;proxy_set_header&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;X-Real-IP&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$remote_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kn&quot;&gt;proxy_set_header&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;X-Forwarded-For&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$proxy_add_x_forwarded_for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kn&quot;&gt;proxy_set_header&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;X-Forwarded-Proto&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$scheme&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这条规则的含义是把向&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://host/app1/*&lt;/code&gt;的请求都转发到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://127.0.0.1:5001/app1/*&lt;/code&gt;，这是与具体的语言、框架无关的。&lt;em&gt;其中转发到的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/app1/&lt;/code&gt;在我的需求中是必要的，在其他需求场景下可能不是，要具体情况具体分析。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;看起来，用子路径访问不同应用的需求已经解决了……吗？试一下发现并没有，App1提供的返回首页的链接会是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://host/&lt;/code&gt;而不是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://host/app1/&lt;/code&gt;，因为它不知道自己被部署到了子路径下面。&lt;/p&gt;

&lt;h2 id=&quot;wgsi&quot;&gt;WGSI&lt;/h2&gt;

&lt;p&gt;WGSI = Web Server Gateway Interface，它不是服务器，仅针对Python定义的一种接口规范（协议）。在这个协议框架下有服务器（Server）和应用（Application，App）两个组成部分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Server的实现有uWSGI、&lt;strong&gt;Gunicorn&lt;/strong&gt;等；&lt;/li&gt;
  &lt;li&gt;Application的实现有Django、&lt;strong&gt;Flask&lt;/strong&gt;等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在WGSI协议中有一个&lt;em&gt;意义不明&lt;/em&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SCRIPT_NAME&lt;/code&gt;参数，根据文档&lt;a href=&quot;https://wsgi.readthedocs.io/en/latest/definitions.html&quot;&gt;Definitions of keys and classes — WSGI.org&lt;/a&gt;中的说明，App可以通过这个参数&lt;strong&gt;知道&lt;/strong&gt;自己的虚拟位置。它默认是个空字符串（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;&quot;&lt;/code&gt;），代表了根路径（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/&lt;/code&gt;）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;SCRIPT_NAME&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;The initial portion of the request URL’s “path” that corresponds to the application object, so that the application knows its virtual “location”. This may be an empty string, if the application corresponds to the “root” of the server.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么显然，在部署时把这个参数设置为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;/app1&quot;&lt;/code&gt;就可以了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;分享个失败的经验，如果误把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SCRIPT_NAME&lt;/code&gt;设置成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;/app1/&quot;&lt;/code&gt;（多了个反斜线），在访问&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://host/app1/&lt;/code&gt;时会出现重定向的死循环。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;gunicorn&quot;&gt;Gunicorn&lt;/h2&gt;

&lt;p&gt;Gunicorn可以用文件进行配置，这个配置文件是个Python脚本，其中标&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;important&lt;/code&gt;的两行非常重要。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;前者决定了柜台开在哪，要与大堂经理（Nginx）的认知（配置文件）一致；&lt;/li&gt;
  &lt;li&gt;后者则是子路径的设置。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# gunicorn.conf.py
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;workers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;threads&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;bind&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;127.0.0.1:5001&apos;&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;# important
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;raw_env&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;SCRIPT_NAME=/app1&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# important
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;accesslog&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;/var/log/gunicorn_access.log&apos;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;errorlog&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;/var/log/gunicorn_error.log&apos;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;loglevel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;warning&apos;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;启动Gunicon的命令为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/srv/web/bin/gunicorn -c ./gunicorn.conf.py run:app&lt;/code&gt;，此时柜台便已开好。&lt;/p&gt;

&lt;h2 id=&quot;flask&quot;&gt;Flask&lt;/h2&gt;

&lt;p&gt;让我们回顾一下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用户访问&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://host/app1/&lt;/code&gt;，Nginx会接收请求；&lt;/li&gt;
  &lt;li&gt;Nginx将请求转发给&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://127.0.0.1:5001/app1/&lt;/code&gt;，Gunicorn会接收请求；&lt;/li&gt;
  &lt;li&gt;Gunicorn知道自己被部署在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/app1/&lt;/code&gt;下面，于是把前缀&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/app1&lt;/code&gt;从请求中拿掉（如果直接访问&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://127.0.0.1:5001/&lt;/code&gt;会因为无法去除前缀而报错），再发给Flask处理；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Flask照常解析、路由即可，但是页面中的链接要怎么保证是正确的呢？&lt;/p&gt;

&lt;p&gt;显然，写死（hard-coding）的部分是无法正确处理的。而通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;url_for()&lt;/code&gt;函数生成的链接，可以读取&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SCRIPT_NAME&lt;/code&gt;的设置，自动加上前缀，从而保证链接是正确的。也就是说，Flask App能正常运行还需要一个前提——&lt;strong&gt;无论是js、css、image之类的静态文件，还是页面之间的链接，都要用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;url_for()&lt;/code&gt;生成。&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{ { url_for(&apos;static&apos;, filename=&apos;css/bootstrap.min.css&apos;) }}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;navbar-brand&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{ { url_for(&apos;index&apos;) }}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;App Home&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;此处还踩了一个坑：Flask配置参数中有个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;APPLICATION_ROOT&lt;/code&gt;看起来更“浓眉大眼”一些，实际上它也能为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;url_for()&lt;/code&gt;生成的链接添加前缀，但它并不能实现我想要的效果。&lt;em&gt;好像是它仅在请求外才能生效，用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;with app.test_request_context()&lt;/code&gt;测试是可以工作，在实际使用时却没生效，没有细究原因。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;总结一下，其实Flask App还是会知道自己被部署到哪里，只是根据协议可以在不改动代码的方式，通过外部参数调整输出。Nginx作为直面用户的一环，根据链接模式（pattern）将请求转发到正确的端口。Gunicorn作为中间层负责处理请求地址并把参数告知Flask，Flask在用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;url_for()&lt;/code&gt;生成链接时再把前缀添加进去，完成闭环。&lt;/p&gt;

</description>
        <pubDate>Sat, 20 Jul 2024 16:57:00 +0000</pubDate>
        <link>http://localhost:4000/2024/07/20/Flask_APP_in_sub_path/</link>
        <guid isPermaLink="true">http://localhost:4000/2024/07/20/Flask_APP_in_sub_path/</guid>
        
        <category>Programing</category>
        
        <category>Flask</category>
        
        
      </item>
    
      <item>
        <title>8b10b编码</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;==本文中存在大量错误，阅读时需谨慎对待。==&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1-介绍&quot;&gt;1. 介绍&lt;/h2&gt;

&lt;p&gt;8b10b编码属于通信系统中的&lt;strong&gt;线路编码&lt;/strong&gt;。线路编码是一种将数字信号转换为电信号的技术，它将数字信号转换为特定的电信号，以便在通信系统中传输和接收数据。线路编码可以提高数据传输的可靠性和稳定性，减少传输过程中的错误和丢失。除了8b10b编码之外，还有其他常见的线路编码技术，例如曼彻斯特编码、差分曼彻斯特编码、4B5B编码等。这些编码技术在不同的应用场景中具有不同的优缺点，需要根据具体的应用需求进行选择。&lt;/p&gt;

&lt;p&gt;8b10b编码是一种将8位数据编码为10位数据的技术，用于在高速串行通信中保证数据传输的可靠性和稳定性。它将8位数据块映射到10位编码块，以便在传输过程中检测和纠正错误。该编码技术还可以实现数据的时钟恢复和数据的流量控制。具体来说，&lt;em&gt;8b10b编码将8个数据位和2个控制位编码成10个符号，其中控制位用于检测和纠正错误，以及控制传输速率和流量&lt;/em&gt;（==此处有误==）。这种编码技术广泛应用于许多领域，包括计算机网络、存储系统、高速数据传输（包括光纤通道、串行ATA和PCI Express）等。&lt;/p&gt;

&lt;p&gt;8b/10b编码的目的之一是&lt;strong&gt;防止串行数据出现长时间的连续0或连续1，从而保证数据传输的DC平衡&lt;/strong&gt;。在传送数据的过程中，如果数据传输信号中出现连续的0或连续的1，就会导致传输信号中的直流偏移（DC offset）偏高或偏低，从而可能会影响接收端的解码能力，导致数据传输错误。为了解决这个问题，8b/10b编码方案采用了一种特殊的编码方式，使得编码后的数据传输信号中的0和1的数量大致相等，从而保证了数据传输的DC平衡，提高了数据传输的可靠性和稳定性。&lt;/p&gt;

&lt;p&gt;8b10b编码的优点包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;可以检测和纠正数据传输中的错误，提高数据传输的可靠性和稳定性。&lt;/li&gt;
  &lt;li&gt;可以实现数据的时钟恢复，避免数据传输过程中时钟漂移导致的错误和数据丢失。&lt;/li&gt;
  &lt;li&gt;可以实现数据的流量控制，避免数据传输过程中的数据堆积和拥塞。&lt;/li&gt;
  &lt;li&gt;可以提高数据传输的带宽效率，减少传输过程中的数据开销。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;8b10b编码的缺点包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;编码后的数据长度比原始数据长度长，会增加数据传输的延迟和开销。&lt;/li&gt;
  &lt;li&gt;编码后的数据传输速率比原始数据传输速率低，会降低数据传输的效率。&lt;/li&gt;
  &lt;li&gt;编码器和解码器的实现比较复杂，会增加系统的设计和开发成本。&lt;/li&gt;
  &lt;li&gt;编码后的数据不便于直接处理和分析，需要进行解码才能得到原始数据。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-编码过程&quot;&gt;2. 编码过程&lt;/h2&gt;

&lt;p&gt;8b10b编码将每个8位的数据块映射到一个10位的编码块上。其中，&lt;em&gt;8位数据被划分为两个4位的组，每个组都被编码成5位的编码&lt;/em&gt;（==此处有误==）。编码采用了一些特殊的规则，以保证编码后的数据具有一定的特性，例如保证连续的0或1的个数不超过5个，以便接收端能够正确识别数据。&lt;/p&gt;

&lt;p&gt;在8b10b编码中，由于&lt;em&gt;每个8位数据都被映射为两个5位编码字&lt;/em&gt;（==此处有误==），因此在传输过程中，可能会出现连续多个编码字的极性相同，导致信号中的直流偏置增加。这会对信号的传输和接收产生负面影响，例如可能导致信号失真、误码率增加等问题。为了解决这个问题，8b10b编码中引入了极性偏差RD（Running Disparity）。RD是一个特殊的编码字，用于在连续多个编码字的极性相同时，改变编码字的极性，从而减少信号中的直流偏置。具体来说，当连续多个编码字的极性相同时，将RD编码字插入到这些编码字之间，可以改变这些编码字的极性，从而减少信号中的直流偏置。&lt;/p&gt;

&lt;p&gt;8b10b编码方案中还包括了一些控制字符，用于控制传输过程中的一些特殊操作，例如同步、流控制等。&lt;/p&gt;

&lt;p&gt;具体的编码过程包括两个步骤：数据编码和控制字符编码。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;数据编码&lt;/p&gt;

    &lt;p&gt;数据编码是将8位数据块映射为10位编码块的过程。具体步骤如下：&lt;/p&gt;

    &lt;p&gt;1）将8位数据块划分为两个4位组；（==此处有误==）
2）对每个4位组进行编码，得到两个5位编码；
3）将两个5位编码合并为一个10位编码块。&lt;/p&gt;

    &lt;p&gt;编码规则如下：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;5B6B编码规则：将4位数据组转化为5位编码，每个编码中包含3个0和2个1或者3个1和2个0，这样可以保证数据传输时的直流分量为0，有利于传输信号的稳定。&lt;/li&gt;
      &lt;li&gt;奇偶校验码：将每个5位编码的1的个数统计出来，如果是偶数，则在编码的最高位加上一个0，如果是奇数，则加上一个1，这样可以保证在传输过程中能够检测出一位错误。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;控制字符编码&lt;/p&gt;

    &lt;p&gt;控制字符编码是将特殊的控制字符映射为10位编码块的过程。控制字符包括同步字符、空闲字符、流控制字符等。这些控制字符的编码方式与数据编码类似，但是它们有特殊的含义，用于控制传输过程中的一些特殊操作。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-编码过程的实现&quot;&gt;3. 编码过程的实现&lt;/h2&gt;

&lt;p&gt;这里提供一个简单的8b10b编码算法的伪代码，供参考：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;定义一个字典，将所有可能的8位二进制序列映射到对应的10位编码序列。&lt;/li&gt;
  &lt;li&gt;将输入的数据序列按8位一组进行分组。&lt;/li&gt;
  &lt;li&gt;对于每组8位数据，查找对应的10位编码序列，并将其添加到输出序列中。&lt;/li&gt;
  &lt;li&gt;每当编码器输出连续的5个1或0时，就会在第6个位上强制改变极性，以消除直流偏移。这个过程也叫做RD控制。&lt;/li&gt;
  &lt;li&gt;返回输出序列。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;伪代码如下（==此处有误==）：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;encode_8b10b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# 定义编码字典
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;encoding_dict&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&apos;00000000&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;1110000000&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&apos;00000001&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;1110000001&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&apos;00000010&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;1110000010&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# ... 其他编码
&lt;/span&gt;        &lt;span class=&quot;s&quot;&gt;&apos;11111110&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;0001111101&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&apos;11111111&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;0001111110&apos;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;# 分组并编码
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;encoded_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&apos;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 记录连续1或0的个数
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;encoded_group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoding_dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# 进行极性控制
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bit&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoded_group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;1&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;encoded_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;0&apos;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoded_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;1&apos;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;1&apos;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;encoded_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bit&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoded_data&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;4-编码前后的对比&quot;&gt;4. 编码前后的对比&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;我本想从功率谱和游程两个方面对比8b10b编码前后的序列，但是编码的Python函数一直没有搞定，只能作罢。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;41-功率谱&quot;&gt;4.1 功率谱&lt;/h3&gt;

&lt;p&gt;在计算功率谱是会用到Welch方法，这是一种非参数估计方法，它将信号分成多个不重叠的段，然后对每个段进行傅里叶变换，最后将这些段的功率谱平均起来。这种方法的优点是可以处理非稳态信号，同时可以有效地减少噪声的影响。&lt;/p&gt;

&lt;p&gt;Welch方法的步骤如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将信号分成多个不重叠的段，每个段的长度为N。&lt;/li&gt;
  &lt;li&gt;对每个段进行窗函数处理，以减少频谱泄漏的影响。常用的窗函数有汉宁窗、汉明窗等。&lt;/li&gt;
  &lt;li&gt;对每个段进行傅里叶变换，得到每个段的功率谱密度。&lt;/li&gt;
  &lt;li&gt;将所有段的功率谱密度取平均，得到最终的功率谱密度。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在实际应用中，Welch方法通常使用Python中的SciPy库中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;signal&lt;/code&gt;模块来实现。其中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;signal.welch&lt;/code&gt;函数可以计算一个信号的功率谱密度，它支持指定分段数、窗函数等参数。&lt;/p&gt;

&lt;p&gt;接着可以使用Matplotlib库来将功率谱以图形的形式展现出来。以下是一个简单的示例代码：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;numpy&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;matplotlib.pyplot&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;scipy&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;plot_power_spectrum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sampling_rate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nperseg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# 计算频率和对应的功率谱密度
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;frequencies&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;power_spectrum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;welch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sampling_rate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nperseg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nperseg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# 绘制功率谱图
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;figure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;figsize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;semilogy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frequencies&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;power_spectrum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xlabel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;frequency (Hz)&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ylabel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;power spectral density&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;Power Spectrum&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该函数使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;signal.welch&lt;/code&gt;函数计算输入序列的功率谱密度，并使用Matplotlib库中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;semilogy&lt;/code&gt;函数绘制功率谱图。其中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;semilogy&lt;/code&gt;函数可以将y轴的刻度标记转换为对数刻度，以更好地展示功率谱的范围。&lt;/p&gt;

&lt;h3 id=&quot;42-游程&quot;&gt;4.2 游程&lt;/h3&gt;

&lt;p&gt;在数字通信中，游程（Run Length）是指一个信号中连续出现的相同符号（或者说是相同的比特）的个数。&lt;/p&gt;

&lt;p&gt;以下是一些Python代码，用于统计一个序列中每种游程出现的次数：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run_length_encoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;encoding&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;current_char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;current_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;current_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;encoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current_char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;current_char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;current_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;encoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current_char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoding&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;count_run_lengths&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;encoding&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;run_length_encoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;counts&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;counts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;counts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counts&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run_length_encoding&lt;/code&gt;函数用于统计游程，它将计算输入序列中连续出现的0和1的数量，然后返回一个包含这些数量的列表。&lt;/p&gt;

&lt;p&gt;例如，如果输入序列为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[1, 1, 0, 0, 0, 1, 1, 1, 1, 0]&lt;/code&gt;，则该函数将返回&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[(1, 2), (0, 3), (1, 4), (0, 1)]&lt;/code&gt;，表示序列中有2个连续的1，3个连续的0，4个连续的1，以及1个单独的0。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count_run_lengths&lt;/code&gt;函数用于计算每个游程出现的次数，该函数首先使用上面的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run_length_encoding&lt;/code&gt; 函数来计算输入序列中的游程，然后使用一个字典来记录每个游程出现的次数。对于每个游程，如果它已经在字典中，则将其计数器加1，否则将其添加到字典中并将计数器设置为1。&lt;/p&gt;

&lt;p&gt;例如，如果输入序列为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[1, 1, 0, 0, 0, 1, 1, 1, 1, 0]&lt;/code&gt;，则该函数将返回&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{2: 1, 3: 1, 4: 1, 1: 1}&lt;/code&gt;，表示有1个长度为2的游程，1个长度为3的游程，1个长度为4的游程和1个长度为1的游程。&lt;/p&gt;

&lt;h2 id=&quot;5-写在最后&quot;&gt;5. 写在最后&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;本文是在ChatGPT（Based on OpenAI API (gpt-3.5-turbo)）的帮助下完成的&lt;/strong&gt;，我主要负责提问和整理答案。同样地在此特别感谢&lt;a href=&quot;https://chatgpt.ddiu.me/&quot;&gt;ChatGPT API Demo (ddiu.me)&lt;/a&gt;的站长提供镜像。&lt;/p&gt;

&lt;p&gt;这次的主要目的是考察ChatGPT写代码的能力，但不知道是我表达方式不准确，还是它的训练库里没有准确的相关知识，它对8b10b的编码方案和编码过程的描述一直是错误的，所以最终也没拿到可直接用的编码脚本。&lt;/p&gt;

&lt;p&gt;根据维基百科&lt;a href=&quot;https://en.wikipedia.org/wiki/8b/10b_encoding&quot;&gt;en.wikipedia.org&lt;/a&gt;和一些常见SerDes协议规格文档，8b10b编码是拆分为5b6b和3b4b两步，并基于极性偏差RD来实现的，我自己也用MATLAB做过实现和验证。但ChatGPT一直认为是拆分成两个4bit来实现，即使在我提醒了它之后依然如此，而RD控制是在我提醒后才加上的。&lt;strong&gt;所以在使用ChatGPT时，一定要警惕它可能是在胡诌。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2023-03-04-8b10b_Encoding.assets/1677938638260.png&quot; alt=&quot;1677938638260&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而在写编码实现的函数时，它一直在尝试按照一一对应关系把mapping表列出来，中途多次因为回复过长而中断。可想而知即使能完整回复，它给出的方案也一定是错误的。&lt;/p&gt;

&lt;p&gt;虽然没有办法拿到ChatGPT提供的编码脚本，但可以让它来写计算功率谱和游程的函数代码。我的体验感受是&lt;strong&gt;它很强，但也需要用的人做好引导&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;一开始，我直接告诉ChatGPT去统计给定序列中每种游程出现的次数，结果就是一次又一次打回修改的过程。虽然它的态度很诚恳，对我指出的错误都很认真的回应，但到了最后直接针对我指出的case在代码里特殊处理，这种打补丁的方式也太过讨打了。最后还是我换了种问法，先让它写计算游程的函数，再基于上个函数写统计游程出现次数的函数，才一遍就输出了正确的代码（&lt;strong&gt;已验证&lt;/strong&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2023-03-04-8b10b_Encoding.assets/1677940935150.png&quot; alt=&quot;1677940935150&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2023-03-04-8b10b_Encoding.assets/1677940949479.png&quot; alt=&quot;1677940949479&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2023-03-04-8b10b_Encoding.assets/1677940962230.png&quot; alt=&quot;1677940962230&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2023-03-04-8b10b_Encoding.assets/1677941202944.png&quot; alt=&quot;1677941202944&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2023-03-04-8b10b_Encoding.assets/1677941253876.png&quot; alt=&quot;1677941253876&quot; /&gt;&lt;/p&gt;

&lt;p&gt;整体的体验感受还是很棒的，尤其是当你只需要提出想法和思路，它就可以很快地把成品带到你的面前，并给出了简单的说明和测试结果供你review时，可以省去了大量需要关心和处理的细节问题。&lt;/p&gt;

</description>
        <pubDate>Sat, 04 Mar 2023 20:02:00 +0000</pubDate>
        <link>http://localhost:4000/2023/03/04/8b10b_Encoding/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/03/04/8b10b_Encoding/</guid>
        
        <category>SerDes</category>
        
        <category>ChatGPT</category>
        
        
      </item>
    
      <item>
        <title>晶体振荡器</title>
        <description>&lt;h2 id=&quot;1-晶体振荡器的介绍&quot;&gt;1. 晶体振荡器的介绍&lt;/h2&gt;

&lt;p&gt;晶体振荡器（XO，Crystal Oscillator，简称为“晶振”）是一种用于产生稳定高精度电信号的电子元器件，广泛应用于计算机、通讯、控制、测量等领域。比如，计算机主板上的时钟晶振、手机中的频率合成器、电视机中的水平振荡器等。&lt;/p&gt;

&lt;p&gt;晶振可以被分为两类：无源晶振和有源晶振，它们的主要区别在于晶振的放大器部分。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;无源晶振是指放大器部分不含有任何有源元件&lt;/em&gt;（==此处有误==），如晶体管、场效应管等。它主要由晶体、LC谐振电路和反馈电路等组成。由于没有放大器的放大作用，因此无源晶振的输出功率较低，适用于一些低功率的应用场景。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有源晶振则是指放大器部分含有有源元件，如晶体管、场效应管等。有源晶振比无源晶振具有更高的输出功率和更好的频率稳定性，因此在一些高功率和高精度的应用场景中得到广泛应用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总的来说，无源晶振和有源晶振各有其适用的场景，需要根据具体应用要求来选择。&lt;/p&gt;

&lt;h2 id=&quot;2-晶振的常用频率以及应用&quot;&gt;2. 晶振的常用频率以及应用&lt;/h2&gt;

&lt;p&gt;晶振的常用频率从几千赫兹到几百兆赫兹不等。其中，高频率的晶振主要用于无线电通讯领域，如手机、WiFi、雷达等；低频率的晶振则主要用于计算机和控制领域。&lt;/p&gt;

&lt;p&gt;除了实时时钟（RTC）的32.768kHz频率，晶振还有很多其他的常用频率和应用。以下是一些例子：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;16MHz - 用于微控制器、单片机等嵌入式系统中，作为系统时钟，控制各种电子元件的工作节奏。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;19.2MHz&lt;/strong&gt; - 用于计算机、单片机、微控制器等嵌入式系统中，作为系统时钟，控制各种电子元件的工作节奏。以及无线电通讯领域中的蓝牙、ZigBee等低功耗无线通讯系统，作为基带时钟，控制数据传输的速率和精度。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;20MHz&lt;/strong&gt; - 用于无线电通讯领域中的WiFi、蓝牙等无线通讯设备，控制无线信号的传输速率。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;26MHz&lt;/strong&gt; - 用于手机GSM、GPRS等通讯模块的射频芯片，控制射频信号的发射和接收。&lt;/li&gt;
  &lt;li&gt;38.4MHz - 用于数字音频、数字视频、ADSL等领域，控制音频、视频、数据传输的速率和精度。&lt;/li&gt;
  &lt;li&gt;38.9MHz - 用于电视机中的色彩振荡器，控制电视图像的颜色显示。&lt;/li&gt;
  &lt;li&gt;40MHz - 用于数字信号处理器（DSP）等高性能处理器中，控制处理器的工作速度。&lt;/li&gt;
  &lt;li&gt;48MHz - 用于手机LTE、WCDMA等高速数据传输模块的射频芯片，控制高速数据信号的传输。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总之，晶振的应用非常广泛，涵盖了计算机、通讯、控制、测量等领域，而不同的应用场景需要不同的频率和精度的晶振。&lt;/p&gt;

&lt;p&gt;而对于射频芯片来说，晶振频率选择与调制系统有关。射频芯片的晶振频率需要与调制系统的频率相匹配，以保证射频信号的传输和接收的稳定性和精度。&lt;/p&gt;

&lt;p&gt;通常，调制系统的频率由基带信号的频率决定，而基带信号的频率又取决于具体的应用场景和需求。例如，对于WiFi通讯系统，基带信号的频率通常在20MHz左右，因此射频芯片的晶振频率也需要在20MHz左右，以保证信号的稳定性和精度。&lt;/p&gt;

&lt;p&gt;此外，射频芯片的晶振频率还需要考虑到其他因素，比如信号的带宽、频率分辨率等，需要根据具体的应用场景来选择合适的晶振频率。&lt;/p&gt;

&lt;h2 id=&quot;3-晶体的压电效应&quot;&gt;3. 晶体的压电效应&lt;/h2&gt;

&lt;p&gt;晶振的核心部件是石英晶体，它是一种具有压电效应的物质。&lt;/p&gt;

&lt;p&gt;晶体的压电效应是指在晶体表面或内部施加压力或形变时，会在晶体中产生电荷或电势差的现象。这种现象是由于晶体的晶格结构具有非对称性，即在某些方向上具有正电荷和负电荷的分布不对称性，当晶体受到外力作用时，晶格结构的对称性被破坏，从而导致电荷分布的不对称性，进而产生电荷或电势差。反之在晶体上施加电场会导致晶体发生形变。&lt;/p&gt;

&lt;p&gt;晶体的压电效应是晶振能够产生稳定高精度信号的基础。&lt;/p&gt;

&lt;h2 id=&quot;4-晶体的电学模型&quot;&gt;4. 晶体的电学模型&lt;/h2&gt;

&lt;p&gt;晶体是一种复杂的物理结构，其电学特性受到多种因素的影响，如晶体的物理尺寸、晶体的材料性质、温度等。这些因素的变化会导致晶体的电学特性发生变化，从而影响晶振电路的性能和稳定性。&lt;/p&gt;

&lt;p&gt;因此，为了方便电路设计和分析，需要将晶体的复杂结构和电学特性用一个简化的模型来代替。这个模型可以根据晶体的实际电学特性和工作条件进行建立，在一定程度上反映晶体的真实行为。采用模型代替晶体，可以将晶振电路简化为一个电路模型，从而方便分析和计算电路的性能参数，如谐振频率、品质因数、稳定度等。&lt;/p&gt;

&lt;p&gt;晶体的电学模型包括晶体的电容、电阻和电感等元件。晶体的谐振频率取决于晶体的物理结构和材料特性，如晶体的厚度、材料种类、晶面取向等。对于等效为电容$C_m$、电感$L_m$、电阻$R_m$串联后与电容$C_0$并联的模型，其谐振频率为&lt;/p&gt;

\[f = \frac{1}{2\pi\sqrt{L_m(C_m+C_0)}}\]

&lt;p&gt;&lt;img src=&quot;/img/in-post/2023-03-03-XTAL_Oscillator.assets/R-C.png&quot; alt=&quot;晶振的等效电路模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在晶振中，晶体的电学模型需要考虑晶体的谐振特性和晶体的非线性特性。晶体的非线性特性会引起谐振频率的变化和谐波的产生，这会影响晶振的稳定性和频谱纯度。因此，在晶振设计中，需要对晶体的电学模型进行精确的建模和仿真，以保证晶振的性能和可靠性。&lt;/p&gt;

&lt;h2 id=&quot;5-典型的晶振电路&quot;&gt;5. 典型的晶振电路&lt;/h2&gt;

&lt;p&gt;CMOS晶振电路是一种常用的集成电路，它可以在一个芯片上实现晶体振荡器和数字电路的集成。以下是几种典型的CMOS晶振电路：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;晶振放大器电路：晶振放大器电路是一种常用的CMOS晶振电路，它由一个共源（CS）放大器和一个反馈电路组成。晶体振荡器的输出信号经过放大器放大后，再经过反馈电路反馈到输入端，从而产生振荡。该电路具有简单、稳定的特点，适用于低频晶振电路。&lt;/li&gt;
  &lt;li&gt;晶振驱动电路：晶振驱动电路是一种用于驱动晶体的电路，它由一个CMOS反相器和一个晶振串联组成。晶体振荡器的输出信号经过反相器反相后再经过晶体，从而产生振荡。该电路具有简单、稳定的特点，适用于低频晶振电路。&lt;/li&gt;
  &lt;li&gt;带有自动校准功能的晶振电路：该电路由一个晶振放大器、一个数字锁相环和一个自动校准电路组成。晶振放大器用于放大晶体振荡器的输出信号，数字锁相环用于调节晶体振荡器的频率，自动校准电路用于对晶体振荡器进行自动校准，从而提高晶振电路的稳定性和精度。&lt;/li&gt;
  &lt;li&gt;带有多种输出波形的晶振电路：该电路由一个晶振放大器、一个多谐振电路和一个输出电路组成。多谐振电路可以产生多种不同频率的振荡信号，输出电路可以将这些信号转换为不同形式的输出波形，如正弦波、方波、三角波等。该电路适用于需要多种输出波形的应用场合。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;6-晶振的启动分析&quot;&gt;6. 晶振的启动分析&lt;/h2&gt;

&lt;p&gt;晶振电路的启动是指在给定的工作条件下，晶体振荡器能够产生稳定的振荡信号。晶振电路的启动与多种因素有关，如晶体的物理结构、工作电压、电路阻抗等。以下是一些常用的分析方法，可以帮助判断晶振电路的启动能否实现：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;负阻法：负阻法是一种常用的判断晶振电路启动的方法。它利用晶体振荡器的负阻特性，通过调节电路的负载阻抗或反馈电路的电容来实现启动。当电路的负载阻抗或反馈电容满足一定条件时，电路会产生自激振荡，从而实现启动。&lt;/li&gt;
  &lt;li&gt;Barkhausen准则：Barkhausen准则是判断振荡电路是否启动的经典方法之一。它要求振荡电路的放大倍数等于回路的衰减因子，当放大倍数和衰减因子满足一定条件时，电路会产生自激振荡。&lt;/li&gt;
  &lt;li&gt;相位准则：相位准则是判断振荡电路是否启动的另一种方法。它要求振荡电路的相位移动为360度，当电路的相位移动满足一定条件时，电路会产生自激振荡。&lt;/li&gt;
  &lt;li&gt;谐振曲线法：谐振曲线法是一种基于频率特性的判断方法。它通过绘制电路的频率响应曲线来确定电路的谐振频率和品质因数，从而判断电路的启动能否实现。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总之，判断晶振电路的启动能否实现需要综合考虑各种因素，采用不同的分析方法可以得到不同的结论，需要根据实际情况进行综合判断。&lt;/p&gt;

&lt;h2 id=&quot;7-晶振的频率精度与频率稳定性&quot;&gt;7. 晶振的频率精度与频率稳定性&lt;/h2&gt;

&lt;p&gt;晶体振荡器的频率精度一般可以用ppm（百万分之一）或ppb（十亿分之一）计量。不同类型、不同精度的晶体振荡器其频率精度也会有所不同。一般来说，晶体振荡器的频率精度在几十ppm到几个ppm之间。以下是一些常见的晶体振荡器频率精度的范围：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;普通的晶体振荡器：频率精度在几十ppm到几百ppm之间。&lt;/li&gt;
  &lt;li&gt;TCXO（温度补偿型晶体振荡器）：频率精度在几ppm到几十ppm之间。&lt;/li&gt;
  &lt;li&gt;OCXO（受控温度晶体振荡器）：频率精度在几ppb到几ppm之间。&lt;/li&gt;
  &lt;li&gt;石英振荡器：频率精度在几ppb到几ppm之间。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要注意的是，&lt;strong&gt;频率精度不同于频率稳定度&lt;/strong&gt;，频率精度是指晶体振荡器输出频率与参考频率之间的偏差，而频率稳定度是指晶体振荡器输出频率随时间的变化程度。因此，在选型时需要同时考虑频率精度和频率稳定度这两个指标。&lt;/p&gt;

&lt;p&gt;晶振的输出频率精准性受到多种因素的影响。以下是一些常见的因素及其简单介绍：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;晶体谐振器的谐振频率精度：晶体谐振器的谐振频率精度决定了整个振荡器的输出频率精准性。晶体谐振器的谐振频率精度受到多种因素的影响，例如晶体的尺寸、晶体的材料、晶体的制造工艺等。&lt;/li&gt;
  &lt;li&gt;电容的精度：晶体振荡器中的电容对于输出频率的精准性也有很大的影响。如果电容的精度不高，就会导致输出频率的偏差。&lt;/li&gt;
  &lt;li&gt;晶振的温度特性：晶振的输出频率会随着温度的变化而发生变化。因此，晶振的温度特性对于输出频率的精准性也有很大的影响。&lt;/li&gt;
  &lt;li&gt;电源噪声：电源噪声也会对晶振的输出频率精准性造成影响。如果电源噪声较大，就会导致输出频率的波动。&lt;/li&gt;
  &lt;li&gt;环境因素：晶振的输出频率还受到环境因素的影响，例如机械震动、电磁干扰等。&lt;/li&gt;
  &lt;li&gt;振荡器电路的稳定性：振荡器电路的稳定性对于输出频率的精准性也有很大的影响。如果振荡器电路不稳定，就会导致输出频率的波动和偏移。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上是一些常见的影响晶振电路输出频率精准性的因素。针对这些因素，可以采取相应的措施来提高晶振的输出频率精准性，例如采用高精度的晶体谐振器、优化电路设计、加入稳定性措施等。&lt;/p&gt;

&lt;h2 id=&quot;8-写在最后&quot;&gt;8. 写在最后&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;本文是在ChatGPT（Based on OpenAI API (gpt-3.5-turbo)）的帮助下完成的&lt;/strong&gt;，我主要负责提问和整理答案。由于那一堵厚厚的墙，我不能直接访问官方网站（&lt;em&gt;虽然花5块钱买了个账号&lt;/em&gt;），因此选择了一个镜像站，在此特别感谢&lt;a href=&quot;https://chatgpt.ddiu.me/&quot;&gt;ChatGPT API Demo (ddiu.me)&lt;/a&gt;的站长。&lt;/p&gt;

&lt;p&gt;在编辑本文的过程中，算是体验了ChatGPT在比较专业的领域的回答水平。必须要承认的是，它在概念解释、举例说明方面已经比普通人强太多了，知识范围广，条理性好，并且很难得的是可以输出自然流畅的中文。从其他人的使用体验看，ChatGPT在写综述、讲稿、总结、润色方面尤其出色，另外在程序员口中也得到了极高的评价，我打算以后多使用它做一些相关工作。&lt;/p&gt;

&lt;p&gt;虽然在使用过程中不出意外地被多次震惊，但有几个点还是让我感到格外欣喜的。比如它在回答中用了一般的公式写法，我想在本文中以Latex格式引用，便有了下面的对话：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2023-03-03-XTAL_Oscillator.assets/1677853338660.png&quot; alt=&quot;1677853338660&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还有我问它参考资料时，它并没有直接把原文链接贴过来，而是仿佛一个电子系毕业生在介绍自己的教育背景。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2023-03-03-XTAL_Oscillator.assets/1677853741995.png&quot; alt=&quot;1677853741995&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然它还是有些需要改善的地方的，比如我一直想让它做一些公式推导和电路设计，但都没有成功。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2023-03-03-XTAL_Oscillator.assets/1677853698972.png&quot; alt=&quot;1677853698972&quot; /&gt;&lt;/p&gt;

&lt;p&gt;无论如何，ChatGPT都是让我感觉到“未来已来”的产品，比所谓的“元宇宙”不知道强到哪里去了（&lt;em&gt;你们没有玩过MMO游戏吗？ – by G胖&lt;/em&gt;）。&lt;/p&gt;

&lt;p&gt;“ChatGPT的效果好不好，完全取决于提问的质量”，引用这句话是想说明，ChatGPT目前仍然是一个工具，一个强大的工具，工具发挥出来的威力和作用还是取决于用的人。当我第一次看到它时，就觉得它对未来的影响不亚于互联网或者iPhone问世，所以对于扑面而来的浪潮不应该躲避，而是要迎面而上，早接触、早熟悉、早应用。&lt;/p&gt;

</description>
        <pubDate>Fri, 03 Mar 2023 21:13:00 +0000</pubDate>
        <link>http://localhost:4000/2023/03/03/XTAL_Oscillator/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/03/03/XTAL_Oscillator/</guid>
        
        <category>XTAL</category>
        
        <category>ChatGPT</category>
        
        
      </item>
    
      <item>
        <title>PLL脚本框架</title>
        <description>&lt;p&gt;在PLL设计过程中需要评估环路的小信号特性，如带宽、相位裕度、增益等，并基于小信号计算最终输出的噪声。通常会用MATLAB或者Python做这件事，当然也有人直接在Virtuoso里用spectre仿真，不过我总觉得不如脚本灵活、快速。对于可量产的芯片来说，这项评估要覆盖各种工艺角和参数偏差，并收集各种计算结果，单纯的用一个脚本很难清晰明了的完成这项任务。此外，有些复杂的级联、嵌套更增加了工作的复杂度，因此我想应该有一种脚本框架可以用来简化工作，提高脚本代码的重用率。&lt;/p&gt;

&lt;h2 id=&quot;以前&quot;&gt;以前&lt;/h2&gt;

&lt;p&gt;早些年，我的想法是把脚本分成两部分，其中一个用来存储参数、计算、展示结果，对于同一结构的PLL来说代码可以完全复用；另一个则是用来赋值和调用前面的脚本。基于这种想法，在一个项目里我会写两个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.m&lt;/code&gt;文件，前者叫&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XXX_PLL.m&lt;/code&gt;，后者叫&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sim_XXX_PLL.m&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XXX_PLL.m&lt;/code&gt;是一个函数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;若调用时不提供参数，则返回一个预定义好的结构体，其中包括了该PLL的所有参数。例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m = XXX_PLL();&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;若调用时提供了结构体参数，则认为该结构体包含了需要评估的PLL参数，基于这些参数计算后返回计算结果，计算结构同样以结构体的形式储存。例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r = XXX_PLL(m);&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;若调用时提供了结构体参数并说明需要展示，则认为该结构体包含了计算结果，基于这组结果展示图表。例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XXX_PLL(r, &apos;show&apos;);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;计算和展示分两步做是为了把计算结果存到工作区，以备后续查看和处理。在计算时会自动展开参数，如设置&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F_in = [20e6, 25e6]; F_out = [2000e6, 2500e6];&lt;/code&gt;则会分别评估组合后的4种情况。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sim_XXX_PLL.m&lt;/code&gt;是一个脚本，我会在里面定义各种模式下PLL所需的参数，如输入输出频率、各模块噪声和增益等，然后把这些参数赋值给通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XXX_PLL.m&lt;/code&gt;得到的结构体，再按上面所示的那样调用两次，得到评估结果。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;此处解释一下，MATLAB中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.m&lt;/code&gt;文件有3种，分别叫做script, function, class。&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;script（脚本）：顺序执行的代码，没有复杂的结构（2016b之后支持局部函数），其操作的变量在命令窗口的工作区（workspace）。换句话说，它与直接在命令窗口敲命令是等价的。&lt;/li&gt;
    &lt;li&gt;function（函数）：包括与文件名同名的主函数和若干局部函数，局部函数仅可在该文件内调用。这是面向过程的编码方式，其本身不能存储任何数据，只有计算、处理的能力。&lt;/li&gt;
    &lt;li&gt;class（类）：包括与文件名同名的类，其下有属性和方法，属于面向对象的编码方式。&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;MATLAB中常用的内置复杂数据类型有struct, cell, table等。&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;struct（结构体）：以键-值对（key-value pair）存储数据，可以通过键名（MATLAB中称之为fieldname）操作所需的数据，键可以随时增减。多个结构体可以构成结构体数组，它们的键保持一致，因此有些时候与表格很像。&lt;/li&gt;
    &lt;li&gt;cell（元胞数组）：常规的数组（矩阵）要求数组内的元素类型和格式必须一致，而元胞数组则没有这种限制，它的每个元素都可以是任意的类型、任意的格式。如结构体的键名便是用元胞数组存储，因为它们虽然都是字符数组，但长度可能不同。需要特别注意的是，与数组用圆括号&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;()&lt;/code&gt;取值不同，&lt;strong&gt;元胞数组需要用花括号&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{}&lt;/code&gt;取值，并且它也支持用圆括号取值，只不过取到的值仍为元胞数组&lt;/strong&gt;。&lt;/li&gt;
    &lt;li&gt;table（表格）：常规数组、结构体、元胞数组在某些条件下都可以转换为表格，而表格的优势在于显示和导出。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;

&lt;p&gt;这种脚本组织方式一直用得很好，既兼顾了代码复用，也不失灵活性。但随着项目的发展，开始暴露出几个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对于新的PLL结构需要改动那个复杂的函数文件；&lt;/li&gt;
  &lt;li&gt;参数组合时没有考虑分组情况，有时候会把两种不可能同时出现的参数组合在一起，导致over-design；&lt;/li&gt;
  &lt;li&gt;组合时没有单独划分typical case，不方便与测试结果对照；&lt;/li&gt;
  &lt;li&gt;不方便处理两颗PLL级联的情况；&lt;/li&gt;
  &lt;li&gt;因为参数与计算结果分别存储，不方便显示报表。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了解决前面的问题，我觉得一个好用的PLL脚本框架应该支持这么几项特性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;较高的代码复用率，对于一种PLL只需要编写部分相应的代码，而这部分代码是单独放置的，不与共用代码搅在一起；&lt;/li&gt;
  &lt;li&gt;支持参数组合，并支持分组，且在组合时划分typical case；&lt;/li&gt;
  &lt;li&gt;方便级联，甚至与CDR级联；&lt;/li&gt;
  &lt;li&gt;可以轻松展示报表，并导出为类似Excel的文件；&lt;/li&gt;
  &lt;li&gt;可以把参数映射为寄存器值，方便调试实际芯片。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;目前&quot;&gt;目前&lt;/h2&gt;

&lt;p&gt;基于此，我构想了一种PLL代码框架，目前实践下来感觉还不错。它包括几个公共类（&lt;em&gt;是的，换成了面向对象编码方式&lt;/em&gt;）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PhaseNoise类：用来存储和计算相位噪声，通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;afterDIV&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;afterCDR&lt;/code&gt;等方法产生衍生的相位噪声，以方便级联；&lt;/li&gt;
  &lt;li&gt;PLL类：抽象类，完成最基本的PLL参数计算，包括&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;calc_H_ol&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;calc_PN&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sim&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show_results&lt;/code&gt;等抽象方法，项目中的实际PLL需要继承该类，然后添加自己的属性，并完成对应的方法实现；&lt;/li&gt;
  &lt;li&gt;Corners类：初始化时存储需要扫描的变量，通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_corner&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_corner_group&lt;/code&gt;等方法产生参数表，再在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run&lt;/code&gt;方法中逐一把参数传递给PLL的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sim&lt;/code&gt;方法，并保存返回的数据，最后把数据汇总形成简报或通过PLL的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show_results&lt;/code&gt;显示。&lt;/li&gt;
  &lt;li&gt;Specs类：静态类，用来存储常用Spec的评估方式和指标。&lt;/li&gt;
  &lt;li&gt;TransferFunction类：静态类，用来完成传递函数的生成和计算。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在使用时主要需要维护两个文件，一个是描述实际PLL的类文件，依然命名为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XXX_PLL.m&lt;/code&gt;，它继承了PLL类，并如前面所述完成了对应方法的实现；另一个是脚本&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sim_XXX_PLL.m&lt;/code&gt;，类似之前的做法，依然把实际参数存在这里，并作为仿真计算的起点。&lt;/p&gt;

&lt;p&gt;这个框架的基本思路是所有与项目相关的代码都编写在前一个文件中，毕竟只有这个类自己才知道这个PLL有哪些参数，如何计算传递函数和噪声，以及如何显示计算结果。如果有不同类型的PLL，可以由任意一个PLL的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sim&lt;/code&gt;方法完成顶层连接关系的描述，也可以单独写一个类。而那些公共类完全不需要修改，甚至可以以加密的方式传给他人使用。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;“工欲善其事，必先利其器”。通过一些小工具提高效率可以更好地完成工作、享受生活。&lt;/p&gt;
</description>
        <pubDate>Sun, 24 Jul 2022 20:34:00 +0000</pubDate>
        <link>http://localhost:4000/2022/07/24/PLL_script_framework/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/07/24/PLL_script_framework/</guid>
        
        <category>PLL</category>
        
        
      </item>
    
      <item>
        <title>markdown中的latex公式</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;喜欢markdown的很重要一点就是能用latex语法写数学公式，而不用安装那庞大的latex环境。但是markdown和latex毕竟“每个人有他的脾气”，所以“相爱没有那么容易”。把一些经验和总结记录下来，已被不时之需。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;基本规则&quot;&gt;基本规则&lt;/h3&gt;

&lt;p&gt;行内时使用两个单美元符号标记（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$...$&lt;/code&gt;），单独行时使用两个双美元符号标记（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$$...$$&lt;/code&gt;），例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;行内的例子（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$x+y=z$&lt;/code&gt;）：$x+y=z$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;单独成行的例子（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$$回车x+y=z回车$$&lt;/code&gt;）：
\(x+y=z\)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果需要使用美元符号，不希望被误识别成公式，则要在前面加反斜杠，即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\$&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;希腊字母greek-alphabet&quot;&gt;希腊字母（Greek Alphabet）&lt;/h3&gt;

&lt;p&gt;在24个希腊字母中，latex支持30个小写字母（包括6个变体写法）和11个大写字母。使用方法非常简单，用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;反斜杠+字母英文名&lt;/code&gt;表示即可，其中字母英文名全小写表示小写希腊字母，首字母大写则表示大写希腊字母。例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\alpha&lt;/code&gt;：$\alpha$，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\delta&lt;/code&gt;：$\delta$&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\Delta&lt;/code&gt;：$\Delta$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2022-05-09-latex_in_markdown.assets/greek_letters.jpg&quot; alt=&quot;greek_aphabet&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;角标&quot;&gt;角标&lt;/h3&gt;

&lt;p&gt;角标的表示同样非常简单，下标用”_“，上标用“^”，若角标的内容超过一个字符则需要用花括号引起来。如果同时存在上下角标可以依次表示，顺序不重要。例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x^2&lt;/code&gt;：$x^2$，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e^{j \omega t}&lt;/code&gt;：$e^{j\omega t}$&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x_1&lt;/code&gt;：$x_1$，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x_1^2&lt;/code&gt;：$x_1^2$&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;分数&quot;&gt;分数&lt;/h3&gt;

&lt;p&gt;分数有两种表示方法，其一是直接用斜杠表示，另外一种是用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\frac{num}{den}&lt;/code&gt;格式。例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a+1)/(b+1)&lt;/code&gt;：$(a+1)/(b+1)$&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\frac{a+1}{b+1}&lt;/code&gt;：$\frac{a+1}{b+1}$&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;根号&quot;&gt;根号&lt;/h3&gt;

&lt;p&gt;平方根的表示方法为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\sqrt{x}&lt;/code&gt;，若要表示n次根号下，则需要添加方括号标记（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\sqrt[n]{x}&lt;/code&gt;）。例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\sqrt{x^2+1}&lt;/code&gt;：$\sqrt{x^2+1}$&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\sqrt[3]{x^2+1}&lt;/code&gt;：$\sqrt[3]{x^2+1}$&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;积分累加符号&quot;&gt;积分、累加符号&lt;/h3&gt;

&lt;p&gt;积分符号可以直接用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\int&lt;/code&gt;调出来，然后通过角标加积分范围，被积分的内容直接写在后面即可。类似的还有累加符号，可以用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\sum&lt;/code&gt;调出来。例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\int_1^2 x dx&lt;/code&gt;：$\int_1^2 x dx$&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\sum_1^2 n&lt;/code&gt;：$\sum_1^2 n$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意，微分符号“d“是以斜体表示的，如果想改为正体需要用到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\mathrm{}&lt;/code&gt;，即&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\int_1^2 x \mathrm{d} x&lt;/code&gt;：$\int_1^2 x \mathrm{d} x$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从中可以看出来，空格在latex公式中是被忽略的，因此大可放心的使用空格增强可读性。&lt;/p&gt;

&lt;h3 id=&quot;括号绝对值符号&quot;&gt;括号、绝对值符号&lt;/h3&gt;

&lt;p&gt;一般情况下，括号直接输入即可，绝对值符号也可以用反斜杠上面的那个（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt;），但这样的缺点是括号高度不会跟着内容变化，解决办法是用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\left&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\right&lt;/code&gt;进行标记。对比一下这两种写法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;( \frac{\frac{a}{b}}{\frac{c}{d}} )&lt;/code&gt;：$( \frac{\frac{a}{b}}{\frac{c}{d}} )$&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\left( \frac{\frac{a}{b}}{\frac{c}{d}} \right)&lt;/code&gt;：$\left( \frac{\frac{a}{b}}{\frac{c}{d}} \right)$&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;常用符号&quot;&gt;常用符号&lt;/h3&gt;

&lt;p&gt;有时候我们还会用到一些特殊符号，比如点乘号、正负号、大于等于、远大于、约等于、箭头等等，均可以用“反斜杠+符号名”的方式表示，当然前提是得知道符号名。常用的有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\cdot&lt;/code&gt;：$\cdot$（点乘号），&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\times&lt;/code&gt;：$\times$（叉乘号），&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\div&lt;/code&gt;：$\div$&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\pm&lt;/code&gt;：$\pm$，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\approx&lt;/code&gt;：$\approx$&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\le&lt;/code&gt;：$\le$，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\ge&lt;/code&gt;：$\ge$，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\ll&lt;/code&gt;：$\ll$，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\gg&lt;/code&gt;：$\gg$（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l&lt;/code&gt;表示less，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g&lt;/code&gt;表示greater，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt;表示equal）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\to&lt;/code&gt;：$\to$，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\downarrow&lt;/code&gt;：$\downarrow$，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\uparrow&lt;/code&gt;：$\uparrow$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多的可参考latex的文档，也可以使用在线编辑器查找，这里推荐“妈咪说”的&lt;a href=&quot;https://www.latexlive.com/&quot;&gt;https://www.latexlive.com/&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;常用函数&quot;&gt;常用函数&lt;/h3&gt;

&lt;p&gt;因为latex在渲染公式时默认使用斜体，但对于一些函数名则可以通过在前面加反斜杠使其变成正体。对比一下这两种写法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sin(x)&lt;/code&gt;：$sin(x)$，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sin^{-1}(x)&lt;/code&gt;：$sin^{-1}(x)$&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\sin(x)&lt;/code&gt;：$\sin(x)$，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\sin^{-1}(x)&lt;/code&gt;：$\sin^{-1}(x)$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类似的还有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cos&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tan&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ln&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;log&lt;/code&gt;等。&lt;/p&gt;

&lt;h3 id=&quot;正体斜体与花体&quot;&gt;正体、斜体与花体&lt;/h3&gt;

&lt;p&gt;如前面提到的，latex在渲染时默认使用斜体，如果想改为正体需要用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\mathrm{}&lt;/code&gt;标记，如果想改为花体则需要用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\mathcal{}&lt;/code&gt;标记。例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;L(f)&lt;/code&gt;：$L(f)$&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\mathrm{L}(f)&lt;/code&gt;：$\mathrm{L}(f)$&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\mathcal{L}(f)&lt;/code&gt;：$\mathcal{L}(f)$ ——常用这个标记代表相位噪声&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;方程式组多行等式&quot;&gt;方程式组、多行等式&lt;/h3&gt;

&lt;p&gt;当使用方程式组或者多行等式时，出于美观的考虑，我们希望等号是上下对齐的，这个时候需要用到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eqnarray&lt;/code&gt;环境，具体的用法如示例：&lt;/p&gt;

&lt;div class=&quot;language-latex highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;\begin{eqnarray}&lt;/span&gt;
a &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt;=&lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; b+c+d &lt;span class=&quot;k&quot;&gt;\\&lt;/span&gt;
c+d &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt;=&lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; e+f+g+h &lt;span class=&quot;k&quot;&gt;\\&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt;&amp;gt;&lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; i+j
&lt;span class=&quot;nt&quot;&gt;\end{eqnarray}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

\[\begin{eqnarray}
a &amp;amp;=&amp;amp; b+c+d \\
c+d &amp;amp;=&amp;amp; e+f+g+h \\
&amp;amp;&amp;gt;&amp;amp; i+j
\end{eqnarray}\]

&lt;p&gt;不难看出，有3个要点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\begin{eqnarray}&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\end{eqnarray}&lt;/code&gt;把需要对齐的部分括起来；&lt;/li&gt;
  &lt;li&gt;需要对齐的部分用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;括起来；&lt;/li&gt;
  &lt;li&gt;行尾需要加&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\\&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;与markdown的冲突和解决方法&quot;&gt;与markdown的冲突和解决方法&lt;/h3&gt;

&lt;p&gt;markdown本身就是一种标记语言，有时候不小心就会出现误识别的现象（如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$&lt;/code&gt;符号），一般可以用反斜杠&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\&lt;/code&gt;解决，例如（可能是mathjax的bug，在Typora中显示正常）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\mathcal{L}_{b}=\mathcal{L}_{b}&lt;/code&gt;：$\mathcal{L}&lt;em&gt;{b}=\mathcal{L}&lt;/em&gt;{b}$&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\mathcal{L}\_{b}=\mathcal{L}\_{b}&lt;/code&gt;：$\mathcal{L}_{b}=\mathcal{L}_{b}$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还有绝对值符号引起的错误（被误识别成表格），则需要把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt;换成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\vert&lt;/code&gt;来解决，例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|H(s)|&lt;/code&gt;：$&lt;/td&gt;
          &lt;td&gt;H(s)&lt;/td&gt;
          &lt;td&gt;$&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\vert H(s) \vert&lt;/code&gt;：$\vert H(s) \vert$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果想输出latex公式的源代码，用反引号标记的代码模式是最方便的，比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\\\$&lt;/code&gt;：\$&lt;/li&gt;
  &lt;li&gt;`\\$`：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\$&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;后记：当年硕士答辩时，被答辩老师吐槽论文里的公式是用Word自带的公式编辑器写的，很丑。多年以后，我只想说——老师说的对啊！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 09 May 2022 22:13:00 +0000</pubDate>
        <link>http://localhost:4000/2022/05/09/latex_in_markdown/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/05/09/latex_in_markdown/</guid>
        
        <category>Programing</category>
        
        
      </item>
    
      <item>
        <title>相位噪声、抖动、EVM与眼图</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;做时钟相关的，总是绕不过去相位噪声、抖动、EVM和眼图，今天再来捋一捋它们之间的“恩怨情仇”。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;基本概念&quot;&gt;基本概念&lt;/h1&gt;

&lt;h2 id=&quot;相位噪声phase-noise&quot;&gt;相位噪声（Phase Noise）&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&quot;http://www.photonics.umbc.edu/Menyuk/Phase-Noise/Vig_IEEE_Standard_1139-1999%20.pdf&quot;&gt;IEEE 1139-1999: IEEE Standard Definitions of Physical Quantities for Fundamental Frequency and Time Metrology—Random Instabilities&lt;/a&gt;中，相位噪声被明确定义如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;2.6 phase deviation φ(t):&lt;/strong&gt; Instantaneous phase departure from a nominal phase.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;2.7 phase instability Sφ(f):&lt;/strong&gt; One-sided spectral density of the phase deviation.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;2.8 phase noise L(f):&lt;/strong&gt; One-half of the phase instability Sφ(f).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从定义不难看出，相位噪声可以通过3步计算得到：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;计算瞬时相位与标定相位的差值，得到相位偏移量。&lt;/strong&gt;但实际测量中标定相位是不存在的，一般通过对待测信号进行拟合得到近似值。另外需要注意到，这里的相位以及相位偏移量都是&lt;em&gt;连续&lt;/em&gt;信号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;计算相位偏移量的&lt;em&gt;单边&lt;/em&gt;谱密度，得到频域的相位不稳定性。&lt;/strong&gt;关于单边谱和双边谱的示意如下图，双边谱即把能量铺到正负频率范围内，单边谱则只考虑正频率范围，因此单边谱的数值是双边谱的两倍。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/in-post/2022-01-23-Phase_Noise_Jitter_EVM_and_Eye_Diagram.assets/onesidedpsd.png&quot; alt=&quot;See the source image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;简单地取相位不稳定性的一半作为相位噪声。&lt;/strong&gt;由于相位偏移量是连续信号，且又不是周期信号，那么得到的谱密度必定是连续曲线。即从定义来说，1kHz的时钟信号可以有1MHz处的相位噪声。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是历史上相位噪声是被定义为&lt;em&gt;载波一定频偏处功率谱密度与载波功率的比值&lt;/em&gt;，也有单边带、双边带之分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2022-01-23-Phase_Noise_Jitter_EVM_and_Eye_Diagram.assets/1642516090379.png&quot; alt=&quot;1642516090379&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当说到单边带相位噪声（SSB phase noise）时指的是只考虑一侧的边带，即$f_0+f$或$f_0-f$处的功率谱密度减去载波功率（以dB为单位）；而当说到双边带相位噪声（DSB phase noise）时指的是考虑两侧的边带，因此就有$\mathcal{L}_{DSB}(f)=\mathcal{L}_{SSB}(f)+3\mathrm{dBc/Hz}$，正好与谱密度的定义相反……&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;为什么会这样？我个人的猜测是：对于频谱来说，只有复信号才必须考虑负频率范围的频谱，实信号的频谱在负频率与正频率范围只是镜像关系，很多时候没必要考虑。而对于载波的边带来说，在频谱上它永远是分布在载波两侧，只是看分析时是否要考虑进去。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么问题就来了，Spectre中pnoise/hbnoise输出的phase noise是哪种？Keysight E5052B测试时显示的是哪种？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在用spectre仿真pnoise时，当选择Noise Type为sources时可以看到下方的提示为SSB。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/in-post/2022-01-23-Phase_Noise_Jitter_EVM_and_Eye_Diagram.assets/1642683523419.png&quot; alt=&quot;1642683523419&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;根据E5052B的Manual，仪器显示的曲线是SSB phase noise，从它计算jitter的方式也可以看出来。（&lt;em&gt;倒数第2行的$\pi$怎么显示的怪怪的&lt;/em&gt;）&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/in-post/2022-01-23-Phase_Noise_Jitter_EVM_and_Eye_Diagram.assets/1642518431770.png&quot; alt=&quot;1642518431770&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，我们可以直接拿spectre的结果与测试结果进行对比，只是在计算jitter时记得乘2就好，就像上面的表格所示的。&lt;/p&gt;

&lt;h2 id=&quot;抖动jitter&quot;&gt;抖动（Jitter）&lt;/h2&gt;

&lt;p&gt;在数字电路、采样电路与有线通信中，抖动是更常用来表示时钟质量的参数。在不同的应用场景下，关注的Jitter类型会有区别，体现在数值上也相去甚远。另外，考虑Jitter的时钟信号一定是Logic形式的，只有“沿”携带信息。&lt;/p&gt;

&lt;p&gt;之前我有总结过一篇&lt;a href=&quot;/2018/10/20/Jitter_Basics/&quot;&gt;Jitter的基本知识&lt;/a&gt;，这次再做一下回顾和补充。&lt;/p&gt;

&lt;p&gt;在提及Jitter的时候一定要记得它是一个统计量，因此要说明是范围（峰峰值，p2p）还是标准差（均方根，rms）。统计样本的不同则对应了不同的Jitter类型。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;标准差（sdev）与均方根（rms）的定义不完全一样，二者的区别在于是否考虑DC分量上。由于我们计算Jitter时会去掉平均值，因此在这里时没有区别的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;absolute-jitter&quot;&gt;Absolute Jitter&lt;/h3&gt;

&lt;p&gt;Absolute jitter（Jabs），也叫Phase jitter、TIE jitter等，指的是&lt;strong&gt;实际时钟沿出现的时刻与理想时钟沿出现的时刻之间的差&lt;/strong&gt;。如计算Phase noise时需要的“标定相位”一样，“理想时钟沿”也是不存在的，一般通过对待测信号拟合得来。&lt;/p&gt;

&lt;p&gt;一般ADC、DAC应用关心这类Jitter的rms值，因为采样时钟的抖动会引起采样到的信号幅度的变化，进而恶化信噪比（SNR）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2022-01-23-Phase_Noise_Jitter_EVM_and_Eye_Diagram.assets/1642903713203.png&quot; alt=&quot;1642903713203&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;period-jitter&quot;&gt;Period Jitter&lt;/h3&gt;

&lt;p&gt;Period jitter（Jp），也叫Cycle jitter，指的是&lt;strong&gt;实际时钟周期与理想时钟周期的差&lt;/strong&gt;，其平均值一般被当作频率偏移。&lt;/p&gt;

&lt;p&gt;在数字电路、类DDR SerDes应用中关心这类Jitter的p2p值，因为时钟的抖动会引起Setup time/Hold time的减小。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;需要注意在Jitter成分中有一类Periodic jitter（PJ），二者是完全不同的概念。Periodic jitter是“周期性的”抖动，即有规律的扰动，属于确定性抖动（DJ）的一种，是相对随机抖动（RJ）而言的。而Period jitter指的是计算Jitter时统计的样本为“周期”。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;cycle-to-cycle-jitter&quot;&gt;Cycle-to-cycle Jitter&lt;/h3&gt;

&lt;p&gt;Cycle-to-cycle jitter（Jc2c或Jcc），也叫Period-to-period jitter、Dperiod jitter等，指的是&lt;strong&gt;相邻的两个时钟周期的差&lt;/strong&gt;。显然这类Jitter与时钟的整体情况机会没有关系，它只体现了非常短期（Short-term）的情况。&lt;/p&gt;

&lt;p&gt;据说在Memory应用中关心这类Jitter。&lt;/p&gt;

&lt;h3 id=&quot;n-period-jitter&quot;&gt;N-Period Jitter&lt;/h3&gt;

&lt;p&gt;N-Period jitter，也叫N-cycle jitter、Accumulating jitter（Jacc）、Long-term jitter等，指的是&lt;strong&gt;连续N个周期总长时间与理想值的差&lt;/strong&gt;，显然N=1时就是Period jitter。&lt;/p&gt;

&lt;p&gt;对于提供同步时钟，但时钟频率低于数据速率的场景会关心这类抖动&lt;/p&gt;

&lt;h2 id=&quot;evm与ipn&quot;&gt;EVM与IPN&lt;/h2&gt;

&lt;p&gt;EVM（Error Vector Magnitude，误差矢量幅度）是无线通信中常用的参数，它表示的是星座图（IQ constellation diagram）上&lt;strong&gt;Symbol的实际位置与理想位置的距离&lt;/strong&gt;。幅度噪声会导致径向偏移，调制时钟的相位噪声则会导致周向偏移，二者都会导致信噪比的恶化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2022-01-23-Phase_Noise_Jitter_EVM_and_Eye_Diagram.assets/1642908029638.png&quot; alt=&quot;1642908029638&quot; /&gt;&lt;/p&gt;

&lt;p&gt;相位噪声对EVM的影响与Jabs对ADC SNR的非常相似，但是在星座图上是被归一化了的（即相对$2\pi$的大小），用秒为单位不太方便，更常用的参数是积分相位噪声（IPN）。类似于相位噪声，IPN同样有单边带、双边带之分，二者的数值上差3dB，E5052B上显示的是单边带IPN。&lt;/p&gt;

&lt;h2 id=&quot;眼图eye-diagram&quot;&gt;眼图（Eye Diagram）&lt;/h2&gt;

&lt;p&gt;眼图是有线通信中最常用的评估信号完整性（SI）的方法，具体的操作就是把波形逐单位间隔（UI）地叠加起来，再去看眼的大小。在叠眼的过程中，触发时钟（Trigger clock）与数据信号的关系对结果有非常重要的影响。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2022-01-23-Phase_Noise_Jitter_EVM_and_Eye_Diagram.assets/eye_digaram_clock.png&quot; alt=&quot;eye_digaram_clock&quot; /&gt;&lt;/p&gt;

&lt;p&gt;比如，如果Tx输出信号是用PLL输出clock的上升沿同步过的，在叠眼图时用同样的clock上升沿进行触发，那么看到的Jitter其实是Period jitter。如果用示波器内置的同频时钟（&lt;em&gt;一般很难做到同频，除非把示波器与测试电路同步起来&lt;/em&gt;）进行触发，那么看到的Jitter其实是Absolute jitter。如果用一个环路自动追踪或恢复出clock作为触发时钟，环路的带宽与配置就会明显地影响看到的Jitter大小。&lt;/p&gt;

&lt;p&gt;因此SerDes标准的兼容性测试规格（CTS）文档中会明确地写出来Golden CRU（时钟恢复单元）的参数，示波器也会提供相应的设置界面。如下图所示，对于一阶的Loop来说只需要提供带宽即可，对于二阶的Loop还要额外提供Peaking或者Damping factor的信息。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;示波器的设置界面上会有两种类型的PLL Spec：低通的JTF和高通的OJTF，其实二者约束的是同一个环路，只不过是从两个不同的角度进行的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2022-01-23-Phase_Noise_Jitter_EVM_and_Eye_Diagram.assets/1642935666545.png&quot; alt=&quot;1642935666545&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;allan方差allan-variance&quot;&gt;Allan方差（Allan Variance）&lt;/h2&gt;

&lt;p&gt;Allan方差是一个在MEMS领域用的比较多的表示器件不稳定性的参数，它的计算方法是&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;设置一定的采样周期，分别计算采样周期内信号（频率或相位）的平均值；&lt;/li&gt;
  &lt;li&gt;再计算这些平均值中相邻两个的差值；&lt;/li&gt;
  &lt;li&gt;再计算这些差值的平方平均数得到方差；&lt;/li&gt;
  &lt;li&gt;以不同的采样周期重复上述步骤，最终得到各采样周期下的方差。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2022-01-23-Phase_Noise_Jitter_EVM_and_Eye_Diagram.assets/1642937052511.png&quot; alt=&quot;1642937052511&quot; /&gt;&lt;/p&gt;

&lt;p&gt;绘制成曲线，横轴是表示采样周期的时间，纵轴是方差，一般用log-log坐标显示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2022-01-23-Phase_Noise_Jitter_EVM_and_Eye_Diagram.assets/v2-733d141f4471353a7f9db44daeb70d21_720w.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Allan方差在通信电路中不太常见（迄今为止只在32k RTC clock相关的测量中考虑过），在这只是提一下。&lt;/p&gt;

&lt;h1 id=&quot;转换&quot;&gt;转换&lt;/h1&gt;

&lt;p&gt;对于同一个时钟信号，可以用不同的参数去描述其质量，这些参数之间可以进行转换。&lt;/p&gt;

&lt;h2 id=&quot;抖动转相位噪声&quot;&gt;抖动转相位噪声&lt;/h2&gt;

&lt;p&gt;我们通常说的抖动是一个数值，它能表示的信息量必然远小于相位噪声曲线，而此处说的抖动指的是统计的样本。&lt;/p&gt;

&lt;p&gt;在介绍IEEE对相位噪声的定义时有提到，相位噪声是相位偏移量的谱密度，而对于Logic形式的时钟，只有沿处的相位是有意义的，如果我们有沿的偏移量数据，便可以得到相应的谱密度，即相位噪声。&lt;/p&gt;

\[\mathcal{L}_{SSB}(f)=\frac{1}{2}{\rm{PSD}_{SSB}}(2\pi\Delta t[i]/T_{avg})\]

&lt;blockquote&gt;
  &lt;p&gt;此处有个近似：时钟沿的时刻的物理含义应当如下图左边所示，即相位都是$2\pi$的整数倍，时间间隔是不均匀的；但在计算中是按照右侧的方式进行的，即时间间隔是均匀的，相位偏移了$2\pi\Delta t[i]/T_{avg}$。在抖动很小的情况下，每段的斜率都近似等于$2\pi/T_{avg}$，因此对结果的影响可以忽略。&lt;/p&gt;

  &lt;p&gt;&lt;img src=&quot;/img/in-post/2022-01-23-Phase_Noise_Jitter_EVM_and_Eye_Diagram.assets/1642940139263.png&quot; alt=&quot;1642940139263&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为$\Delta t[i]$是离散的实信号，那么其频谱只有在0~fs/2范围内有意义，而fs等于时钟的频率，也就是说对于1GHz的时钟信号，通过这种方式只能看到500MHz以内的相位噪声。一般来说也够用了，但对于有些场景还是要注意一下，比如&lt;a href=&quot;/2015/08/23/NDIV&apos;s_Phase_Noise_Due_To_SDM/&quot;&gt;SDM对分频器输出信号相位噪声的影响&lt;/a&gt;中便用到了这种方法计算SDM对MMD输出时钟相位噪声的影响，需要注意到高于fs/2的频偏处的相位噪声对于PLL来说仍然是有意义的。&lt;/p&gt;

&lt;h2 id=&quot;相位噪声转抖动&quot;&gt;相位噪声转抖动&lt;/h2&gt;

&lt;h3 id=&quot;absolute-jitter-1&quot;&gt;Absolute Jitter&lt;/h3&gt;

&lt;p&gt;假设相位噪声引起的抖动呈高斯分布，根据随机过程的相关知识（&lt;em&gt;啊……随机过程的知识已经忘干净了……&lt;/em&gt;），对相位噪声曲线积分后换算到秒为单位便是Jabs的rms值，与前面E5052B manual的表格内的公式相同。&lt;/p&gt;

\[{\rm Jabs_{rms}}=\frac{T_{avg}}{2\pi} \sqrt{2\int_{f0}^{f1}10^{\mathcal{L(f)}/10}{\rm d}f}=\frac{1}{2\pi f_c} \sqrt{2\int_{f0}^{f1}10^{\mathcal{L(f)}/10}{\rm d}f}\]

&lt;p&gt;显然积分范围对得到的数值有重要影响：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于数字无线通信系统，一般f0取Packet length的倒数，f1取Symbol rate的一半；&lt;/li&gt;
  &lt;li&gt;对于ADC、DAC则取全频带，因为采样时存在折叠现象，但对于过采样系统则可以在折叠后排除掉带外的噪声；&lt;/li&gt;
  &lt;li&gt;对于有线通信系统，$\mathcal{L}(f)$要先乘上OJTF，再取f0=0，f1=2/UI。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实际操作中，由于E5052B的测量范围有限（普通模式下1.5GHz以上的时钟信号能测到100MHz频偏，Wide capture range模式下只能测到40MHz；普通模式下1.5GHz以下能测到40MHz，101MHz以下能测到20MHz，41MHz以下只能测到5MHz），而PLL输出的相位噪声在转成Jabs时通常是带宽附近占比最大，因此直接积全频带也是OK的。&lt;/p&gt;

&lt;p&gt;另外在实际情况中，伴随着相位噪声的还有杂散（Spurious），它引入的抖动属于DJ，在计算时要分别对待。E5052B提供了Omit功能把Spur引入的影响扣除掉，示波器则是通过对抖动样本做频域分析，滤除明显的周期性信号后得到RJ。&lt;/p&gt;

&lt;h3 id=&quot;period-jitter-1&quot;&gt;Period Jitter&lt;/h3&gt;

&lt;p&gt;假设Jabs的样本是$\Delta t[i]$，Jp的样本则是$\Delta t[i]-\Delta t[i-1]$，即引入了传递函数为$H(z)=1-z^{-1}$的差分模块。&lt;/p&gt;

&lt;p&gt;由$z=e^{sT_s}, s=j\omega$可得&lt;/p&gt;

\[H(\omega)=1-e^{-j\omega T_s}\]

&lt;p&gt;再带入欧拉公式$e^{jx}=\cos x+j\sin x$可得&lt;/p&gt;

\[\begin{array}{l}
\vert H(\omega) \vert ^2 &amp;amp;= \vert 1-[\cos(-\omega T_s)+j\sin(-\omega T_s)] \vert ^2 \\
&amp;amp;= [1-\cos(\omega T_s)]^2+\sin^2(\omega T_s) \\
&amp;amp;= 2\cdot[1-\cos(\omega T_s)] \\
&amp;amp;= 4\cdot\sin^2(\omega T_s/2) \\
\end{array}\]

&lt;p&gt;这里的$T_s$即为$T_{avg}$，代入相位噪声到抖动的计算公式整理可得&lt;/p&gt;

\[{\rm Jp_{rms}}=\frac{1}{2\pi f_c} \sqrt{2\int_{f0}^{f1}4\cdot\sin^2 (\pi f/f_c)\cdot10^{\mathcal{L(f)}/10}{\rm d}f}\]

&lt;p&gt;不难看出这个传递函数在$f=f_c/2$处的增益最高（6dB），而对低频的抑制非常大，也就是说低频噪声几乎不影响Jp，主要起作用的是底噪（Noise floor）。而由于前面提到过的E5052B测不到很高的频偏，且从电路的角度讲Clock buffer chain主要影响的是底噪，所以在实际项目中很难测到真实的Jp情况。&lt;/p&gt;

&lt;h3 id=&quot;cycle-to-cycle-jitter-1&quot;&gt;Cycle-to-cycle Jitter&lt;/h3&gt;

&lt;p&gt;与Jp类似，再叠加一次差分传递函数，因此&lt;/p&gt;

\[{\rm Jc2c_{rms}}=\frac{1}{2\pi f_c} \sqrt{2\int_{f0}^{f1}16\cdot\sin^4 (\pi f/f_c)\cdot10^{\mathcal{L(f)}/10}{\rm d}f}\]

&lt;p&gt;也就是说Jc2c更加看重底噪的情况。&lt;/p&gt;

&lt;h3 id=&quot;n-period-jitter-1&quot;&gt;N-Period Jitter&lt;/h3&gt;

&lt;p&gt;与Jp类似，只不过传递函数变成了$H(z)=1-z^{-n}$，即$\vert H(\omega) \vert ^2=4\cdot\sin^2(\omega \cdot n T_s/2)$，因此可得&lt;/p&gt;

\[{\rm Jc2c_{rms}}(n)=\frac{1}{2\pi f_c} \sqrt{2\int_{f0}^{f1}4\cdot\sin^2 (n\pi f/f_c)\cdot10^{\mathcal{L(f)}/10}{\rm d}f}\]

&lt;blockquote&gt;
  &lt;p&gt;就这些吧，这篇跟之前的那篇的区别不大，主要是把推导过程也写上了。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 23 Jan 2022 22:48:00 +0000</pubDate>
        <link>http://localhost:4000/2022/01/23/Phase_Noise_Jitter_EVM_and_Eye_Diagram/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/01/23/Phase_Noise_Jitter_EVM_and_Eye_Diagram/</guid>
        
        <category>PLL</category>
        
        
      </item>
    
      <item>
        <title>遗传算法</title>
        <description>&lt;h1 id=&quot;基本原理&quot;&gt;基本原理&lt;/h1&gt;

&lt;p&gt;遗传算法（Genetic Algorithm，GA）的目的是解决最优化问题，基本原理则是模仿生物&lt;em&gt;自然选择或进化&lt;/em&gt;的过程。&lt;/p&gt;

&lt;p&gt;具体的，它把问题的解分成若干个&lt;strong&gt;基因&lt;/strong&gt;，这些基因合为一个&lt;strong&gt;个体&lt;/strong&gt;（也就是每个个体是一个潜在的解，每个基因是一个独立变量）。若干个体组成&lt;strong&gt;种群&lt;/strong&gt;，通过一定的方式给种群中的每个个体&lt;strong&gt;打分&lt;/strong&gt;（计算&lt;em&gt;适应度&lt;/em&gt;），其中得分较高的部分个体（&lt;em&gt;选择&lt;/em&gt;）可以&lt;strong&gt;繁殖&lt;/strong&gt;产生后代。繁殖的过程包括&lt;strong&gt;杂交&lt;/strong&gt;和&lt;strong&gt;变异&lt;/strong&gt;，杂交表示新产生的个体的基因继承自两个长辈个体，变异表示基因会在原来的基础上产生一定的、随机的变化。选择和繁殖的过程会不断地改变群体里个体的基因，使其代表的解逐渐地向最优解靠近。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2021-08-07-Genetic_Algorithm.assets/basic.svg&quot; alt=&quot;basic&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;举个例子&quot;&gt;举个例子&lt;/h1&gt;

&lt;p&gt;通过遗传算法模拟生物外貌进化的过程。假设这种生物的外观也是RGB色彩空间的，我们通过选择与下图最相似的个体进行繁殖，看它们的演化过程是怎样的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;该图案是中央气象台nmc.cn的logo。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2021-08-07-Genetic_Algorithm.assets/ref.png&quot; alt=&quot;ref&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先定义几个常数&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# 每次选择出来的个体数
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N_UNIT_TOP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 筛选代数（迭代次数）
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N_LOOP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 杂交时的交叉率：有多少比例的基因来自对方个体
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RATE_CROSS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.4&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 变异率
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RATE_CHANGE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.2&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 变异时的标准差
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RATE_CHANGE_STD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.05&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后进行一些准备工作，包括读取参考图案、确定基因个数和种群大小、初始化记分牌之类的。&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# 读取参考图案，确定基因个数和种群大小
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pic_ref&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FNAME_REF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;png&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;N_W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N_H&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N_C&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pic_ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;N_GENE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N_W&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N_H&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;N_UNIT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N_UNIT_TOP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 记分牌
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;score_rcd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;unit_rcd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;unit_ref&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pic_ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reshape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N_GENE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来就是重头戏了，为了方便起见先把计算适应度和产生后代的过程写成函数。&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# 计算适应度
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_score&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit_ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unit_ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 产生后代
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;gen_child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unit_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit_y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;choice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N_GENE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RATE_CROSS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N_GENE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;idx2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;choice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N_GENE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RATE_CHANGE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N_GENE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;change&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N_GENE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RATE_CHANGE_STD&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;unit_new&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unit_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;unit_new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit_y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;unit_new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;change&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;unit_new&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unit_new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit_new&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;遗传算法的主要部分是一个循环，每次循环做一次&lt;strong&gt;繁殖-适应-选择&lt;/strong&gt;的迭代。&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_loop&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N_LOOP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;i = &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; / &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N_LOOP&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# 繁殖
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# 初始化种群：通过随机
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N_GENE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N_UNIT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# 杂交与变异：每两个不同的个体分别以自身为主、对方为辅进行杂交
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N_UNIT_TOP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N_UNIT_TOP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gen_child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# 打分（计算适应度）
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;scores&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_score&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit_ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;# 选择，并记录下本轮中最佳的个体和得分
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sorted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scores&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N_UNIT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;score_rcd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scores&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]])&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;unit_rcd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]])&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N_UNIT_TOP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;展示一下最终的结果：下图中左上角的为参考图案，其他的从左到右、从上到下是从初始一代到最后一代（相邻的两张图间隔了100代）各代中最佳的个体（即分最高的个体）。可以看到从完全没有图案到出现图案，再到图案逐渐清晰的过程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2021-08-07-Genetic_Algorithm.assets/plot_1000.png&quot; alt=&quot;plot_1000&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对应的各代最佳个体的分数变化如下图所示，可见600代后适应度分数的变化趋于平缓了，也对应了上图中图案清晰度的变化没那么大。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2021-08-07-Genetic_Algorithm.assets/score_1000.png&quot; alt=&quot;score_1000&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参考图案的尺寸是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;35x35&lt;/code&gt;像素，即基因的个数是3675个。在种群中个体的数量是100个、共迭代了1000代的情况下，耗时和各部分的比例如下。需要注意这个例子中计算适应度的函数非常简单，也就是说一般情况下产生新个体并不麻烦，评价个体的情况是花费时间最多的地方。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Generate: 74.49s (31.90%)&lt;/p&gt;

  &lt;p&gt;Score: 158.36s (67.82%)&lt;/p&gt;

  &lt;p&gt;Select: 0.64s (0.27%)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;具体应用&quot;&gt;具体应用&lt;/h1&gt;

&lt;p&gt;具体到实现，第一步则是要把实际问题转化为可以用遗传算法求解的模型，这个模型有两个重要的组成部分：独立变量和评价方法。&lt;/p&gt;

&lt;p&gt;如前面所说的，问题的解对应了算法中的“个体”，而其最小组成部分“基因“则对应了独立变量。实际问题里有些参数可能存在着关联，变量过多会导致求解困难，因此需要尽量提取其相互独立的部分。变量的取值可以是小数，也可以是整数，甚至是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;。通过确定独立变量，便把解空间确定了下来。&lt;/p&gt;

&lt;p&gt;求解过程实际上是一种搜索过程，要有一个能够判断解是否够好的量化方法，通过这个方法才能实现“选择”过程。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;emmm……我本打算尝试用遗传算法去根据频率响应产生FIR滤波器参数，可是调了好久都没达到预期的效果，看来我还需要再学习一下。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;一些思考&quot;&gt;一些思考&lt;/h1&gt;

&lt;p&gt;之所以看遗传算法，一方面是因为在网上看到类似枯叶蝶之类的动物（以及更多的&lt;a href=&quot;https://www.sohu.com/a/145335883_737109&quot;&gt;自然界伪装高手 - 搜狐&lt;/a&gt;）时，总会有人说这么完美怎么可能是进化来的，一定是有“神”来设计。当然更多的人对这种观点是嗤之以鼻的，我就想可以借用遗传算法说明一下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;进化=随机突变+自然选择&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2021-08-07-Genetic_Algorithm.assets/butterfly.gif&quot; alt=&quot;枯叶蝶&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另一方面是因为近几年人工智能大火，点开&lt;a href=&quot;https://ieeexplore.ieee.org/popular/all&quot;&gt;IEEE TOP SERACHES&lt;/a&gt;就会看到有近一半关键词与人工智能或者机器学习相关；常逛的EETOP也被站长把“AI”设置成了关键词，普通单词里挨着的俩字母也经常会被误认而改成大写划上下划线，搞得莫名其妙。我想应该稍微去涉猎一下，免得被时代落下太多。而人工智能的三大模型（专家系统、遗传算法、神经网络，好像也有其他的说法）中遗传算法最为简洁、直接，便从这下了手。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;以我个人目前浅显的调研来看，会影响到模拟集成电路设计领域的应该是专家系统模型，这也是最需要积累和普通电路设计者参与的模型，神经网络最多能在“小问题”和“模糊问题”上做一些加强。&lt;/p&gt;

  &lt;p&gt;神经网络的优势应该在于解“模糊问题”，如应对语音、手写文字、图像等等。这类问题的特点是很难用&lt;strong&gt;明确&lt;/strong&gt;的方法得到解，而神经网络通过大量的参数和漫长的自动调参（训练）得到一组参数，使其能&lt;strong&gt;大概率&lt;/strong&gt;地实现想要达到的目的。这种&lt;strong&gt;通用&lt;/strong&gt;的方法看起来非常amazing，近几年飞速增长的算力也有了用武之地，但它的问题在于模型的训练要依赖大量的试错。在模拟集成电路设计中，有很多仿真需要较长的时间去覆盖所有的corner，诚然我们可以给出&lt;em&gt;经验上的&lt;/em&gt;worst case来缩短这个过程，但可能也不是训练过程能接受的。&lt;/p&gt;

  &lt;p&gt;我想最可能的方法是把常用的电路结构量化分析透彻（比如经常被拿来举例的运算放大器和LDO），每个管子的功能和参数对整体的影响都写入“知识库”，这样当给出所需的规格时，计算机就可以根据“知识库”的信息自动找到最佳设计方案，甚至直接给出GDS。当换到一个未知的新工艺时，也只需要补充“知识库”的内容即可。打个比方，理论上DC和瞬态仿真是最精准的，用瞬态仿真也可以确定放大器的增益、噪声、稳定性等等，那为什么还需要小信号模型、反馈理论呢，还不是因为这样快嘛！因此我的观点是，模拟集成电路设计自动化的关键在于——&lt;strong&gt;抽象&lt;/strong&gt;。要把实际工程中会用到的电路模块按类别抽象成模型，翻译成计算机能理解的“知识”。但这样相当于把训练神经网络变成了训练工程师，至少人的归纳、总结、演绎能力目前还是有优势……的吧？&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sat, 07 Aug 2021 13:46:52 +0000</pubDate>
        <link>http://localhost:4000/2021/08/07/Genetic_Algorithm/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/08/07/Genetic_Algorithm/</guid>
        
        <category>Others</category>
        
        
      </item>
    
      <item>
        <title>可靠性与ESD介绍</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;MediaTek再一次在东南大学和西安电子科技大学举办了暑期夏令营，今年的模拟IC部分由我来讲（之前的讲师没时间），PPT因为信息安全问题拿不出来，我就把讲稿整理了一下形成本文。&lt;/p&gt;

  &lt;p&gt;这是第二部分的讲稿，第一部分是&lt;a href=&quot;/2021/07/31/SerDes_Trends_and_Key_Technologes_In_Consumer_Electronics/&quot;&gt;消费电子中SerDes的发展趋势和关键技术&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;1-标题&quot;&gt;1. 标题&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;上一部分很多同学可能听得有点云里雾里，这是正常现象，一方面是我讲得还不够通俗易懂，另一方面是毕竟行业高度细化，不同方向的知识储备大相径庭。不过我觉得没必要记住每个细节，只要能留下点印象就算没白听。等到哪天你遇到了什么问题，然后脑中灵光一闪：“哎，我好像在哪听过一个什么讲座，里面有这种问题的解法”。然后仔细一想，记起来几个词，顺着这几个关键词在Google上找到了相关的内容，或许就能解决你的问题。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;这部分我们就讲点通俗的、更偏向实际应用的内容——可靠性与ESD。不过大家在学校里做的项目可能还不太关注这部分，但对于真正量产的产品来说是至关重要的。接下来我会做一些介绍，希望大家可以有所收获。&lt;/p&gt;

&lt;h3 id=&quot;2-自我介绍&quot;&gt;2. 自我介绍&lt;/h3&gt;

&lt;p&gt;这部分就跳过了。&lt;/p&gt;

&lt;h3 id=&quot;3-课程安排&quot;&gt;3. 课程安排&lt;/h3&gt;

&lt;p&gt;我大约会用30分钟的时间来分享我对可靠性和ESD的认识。&lt;/p&gt;

&lt;h3 id=&quot;4-大纲&quot;&gt;4. 大纲&lt;/h3&gt;

&lt;p&gt;分别会介绍可靠性和ESD是什么，然后讲一下它们是怎么测的，如果有什么问题可以在问答环节向我提问。&lt;/p&gt;

&lt;h3 id=&quot;5-可靠性介绍&quot;&gt;5. 可靠性介绍&lt;/h3&gt;

&lt;p&gt;首先请大家回忆一下，你买的电子产品多久会坏？坏掉的原因是什么？&lt;em&gt;我记得我小时候，电视机之类的东西坏掉的时候都会用力拍几下，或许就能拍好。这是因为有接触不良，拍几下带来的震动让它恢复接触了，也就暂时解决了故障。现在大家生活条件好了，电子产品的价格也下来了，这种“传统手艺”好像都要失传了……&lt;/em&gt;大家年纪比较小，正好赶上了数码产品大换代的时候，是不是还没等到用坏就淘汰了？那我们设计的芯片会因为用得久了而坏掉吗？如何保证芯片能用到被淘汰？&lt;/p&gt;

&lt;p&gt;事实上芯片工作的久了的确会有出现故障的现象，它的原因是多样的，让我们逐一看一下。&lt;/p&gt;

&lt;h3 id=&quot;6-热载流子注入hci&quot;&gt;6. 热载流子注入（HCI）&lt;/h3&gt;

&lt;p&gt;第一个是热载流子注入效应，它是因为沟道里的载流子在横向移动的时候会撞到氧化层上，氧化层是很薄的，载流子撞穿后会形成栅极电流或者衬底电流，这会导致管子的跨导下降或者阈值电压上升。对应到应用就是数字电路会因此增大延迟时间，模拟电路会因此出现增益下降。记住这个效应出现的条件是载流子在沟道里快速移动时。&lt;/p&gt;

&lt;h3 id=&quot;7-负偏压温度不稳定性nbti&quot;&gt;7. 负偏压温度不稳定性（NBTI）&lt;/h3&gt;

&lt;p&gt;负偏压温度不稳定性效应，这个效应出现在PMOS上，因为空穴在负偏压下会注入到栅极氧化层，造成管子的阈值电压增大、沟道饱和电流减小。同样的，NBTI效应也会造成电路的性能下降。它出现的条件是PMOS，并且栅极电压比衬底低。&lt;/p&gt;

&lt;h3 id=&quot;8-经时击穿tddb&quot;&gt;8. 经时击穿（TDDB）&lt;/h3&gt;

&lt;p&gt;与时间相关的介电质击穿效应，或者叫经时击穿效应，这个效应产生的原因是氧化层中间会随机地出现缺陷，叫做“电子陷阱”。这些缺陷如果连在了一起，从正极一直连到负极，就会导致电流导通，即为“击穿”。它轻则会导致漏电增大，重则会导致器件失效。这个效应出现的条件是栅极和衬底的电压不一致。&lt;/p&gt;

&lt;h3 id=&quot;9-可靠性举例&quot;&gt;9. 可靠性举例&lt;/h3&gt;

&lt;p&gt;让我们来看一个简单的例子，这是一个反相器，给它输入“高低高低”的波形，它会输出“低高低高”的波形。那么前面所述的几种效应会分别出现在什么时期呢？&lt;/p&gt;

&lt;p&gt;热载流子注入效应出现在沟道里有载流子快速移动时，那就对应了反相器状态翻转时，就是右图中的A、C期间，无论PMOS还是NMOS都会受这个效应影响；&lt;/p&gt;

&lt;p&gt;负偏压温度不稳定性效应出现在PMOS的栅压低于衬底电压时，即为D期间，只有PMOS受这个效应影响；&lt;/p&gt;

&lt;p&gt;经时击穿出现在栅压和衬底电压不一致时，对于NMOS是B期间，对于PMOS是D期间。&lt;/p&gt;

&lt;h3 id=&quot;10-大纲&quot;&gt;10. 大纲&lt;/h3&gt;

&lt;p&gt;好了，可靠性就简单地介绍完了，接下来让我们看看ESD。&lt;/p&gt;

&lt;h3 id=&quot;11-esd介绍&quot;&gt;11. ESD介绍&lt;/h3&gt;

&lt;p&gt;ESD的全称是什么？静电释放。&lt;em&gt;说起静电大家应该不会陌生，北方的冬天特别明显，尤其是一些体质特异的人，简直都成皮卡丘了，不管到哪都是一路火花带闪电。&lt;/em&gt;这些静电打到门把手上是无所谓的，要是打在电子设备上会怎么样？&lt;/p&gt;

&lt;h3 id=&quot;12-esd介绍续&quot;&gt;12. ESD介绍（续）&lt;/h3&gt;

&lt;p&gt;电子设备上通常会有很多接口，接口再通过导线连接到芯片的管脚上，然后连到芯片内部。静电释放时产生的高电压可能会击穿管子，大电流可能会烧熔器件。那么要怎么防护呢？&lt;/p&gt;

&lt;h3 id=&quot;13-esd介绍续&quot;&gt;13. ESD介绍（续）&lt;/h3&gt;

&lt;p&gt;让我们想一想人们是如何应对雷击的，用避雷针。但关键点在于避雷针吗？不知道大家有没有留意过，建筑物除了在顶上放避雷针外，还要用一根很粗的导线从避雷针引到地下，埋在很深的地方。正是这根导线提供了一条到地的、阻抗远低于建筑物本身的通道，才能旁路分流走绝大部分电流，从而保护了建筑物。&lt;/p&gt;

&lt;h3 id=&quot;14-放电路径&quot;&gt;14. 放电路径&lt;/h3&gt;

&lt;p&gt;同样的道理，如果我们能提供一条针对静电的放电通道，也可以保护内部的电路。如这张图所示的，无论输入、输出还是电源、地，都有ESD保护电路。&lt;/p&gt;

&lt;h3 id=&quot;15-放电路径续&quot;&gt;15. 放电路径（续）&lt;/h3&gt;

&lt;p&gt;让我们来看看保护电路是如何工作的。以这幅图为例，假如输入PAD上出现了一个正的电流脉冲，首先会通过二极管向电源放电；如果电源没能泄放掉，ESD检测电路会把连接在电源和地之间的管子打开，把电流向地上引导；如果到了地上仍然没有放完，电流会通过二极管流向输出PAD。这些通道可以提供无论是从哪到哪、无论是正是负的低阻通道，可以快速地旁路掉电流，保护内部电路。&lt;/p&gt;

&lt;h3 id=&quot;16-大纲&quot;&gt;16. 大纲&lt;/h3&gt;

&lt;p&gt;说完了原理，让我们来看看如何进行测试。&lt;/p&gt;

&lt;h3 id=&quot;17-芯片失效率&quot;&gt;17. 芯片失效率&lt;/h3&gt;

&lt;p&gt;首先大家要知道产品的失效率存在这么一个现象，失效率随着时间先减少，再稳定，再增加，与人的健康状况随年龄的变化相似，呈现出两头高中间低的浴盆形状。如果我们能尽量的筛除早期失效的，那么到客户手里的就会是稳定的、健康的产品。&lt;/p&gt;

&lt;h3 id=&quot;18-流片后测试&quot;&gt;18. 流片后测试&lt;/h3&gt;

&lt;p&gt;在设计时，不同规格的产品对寿命的要求是不一样的，比如消费级通常是2~5年，工业级是5~10年，车用的会更久。同时对温度、湿度也有不同的要求，对失效率的容忍程度也不一样。&lt;/p&gt;

&lt;p&gt;在芯片封装完后，经过最终测试，会进行可靠性测试，再交付给用户，以保证使用寿命和失效率。但是我们在测试时不可能真的测两年或者五年，那怎么办呢？&lt;em&gt;当然有的产品是真的会去测能用多久，比如圆珠笔芯、中性笔芯，他们真的会用机械臂拿着笔芯去划，测试墨水写多长后会用完，以及滚珠会不会提前掉下来。&lt;/em&gt;对于芯片来说我们可以去测各种应用场景的功能，但是可靠性要怎么测？如果不测的话你怎么能向客户证明这个产品是可以坚持几年的使用时间呢？&lt;/p&gt;

&lt;h3 id=&quot;19-加速可靠性测试&quot;&gt;19. 加速可靠性测试&lt;/h3&gt;

&lt;p&gt;答案就是改变测试条件，从前面的原理介绍我们可以知道失效效应与电压、温度相关，在高温、高压下更容易出现失效，因此可以做一个等效，在高温高压下工作若干时间，相当于在常温常压下工作了多少倍的时间。这个测试方法是不是偷懒？是，但是没有更好的办法。&lt;/p&gt;

&lt;h3 id=&quot;20-高温老化测试&quot;&gt;20. 高温老化测试&lt;/h3&gt;

&lt;p&gt;这种在高温高压下测试使用寿命的测试项称作高温老化试验HTOL，属于固态技术协会制定的测试标准清单中的一项。而这个技术协会里有大家几乎所有耳熟能详的集成电路公司，所以这是业界公认的测试方法。&lt;/p&gt;

&lt;h3 id=&quot;21-高温老化测试条件与规格&quot;&gt;21. 高温老化测试条件与规格&lt;/h3&gt;

&lt;p&gt;这里列出来了其中的测试条件和规格，比如消费级产品要在1.1倍电源电压、85摄氏度环境温度下工作200~500小时，然后再测试电路是否能正常工作、性能有多少衰减等。下面的表格列出的是器件级的规格，这里就不展开讲了。&lt;/p&gt;

&lt;h3 id=&quot;22-大纲&quot;&gt;22. 大纲&lt;/h3&gt;

&lt;p&gt;接着看一下ESD的测试。&lt;/p&gt;

&lt;h3 id=&quot;23-esd测试流程&quot;&gt;23. ESD测试流程&lt;/h3&gt;

&lt;p&gt;同样的，ESD测试也属于测试标准，它分成几个测试Case，让我们依次看一下。&lt;/p&gt;

&lt;h3 id=&quot;24-esd测试模型---人体模型hbm&quot;&gt;24. ESD测试模型 - 人体模型（HBM）&lt;/h3&gt;

&lt;p&gt;首先是模拟人用手触摸芯片时的情况，叫做人体模型。假设人体带电，去碰触芯片的一根管脚，产生放电现象。它的模型如右图所示，测试时先把开关拨到左边对电容充电，再把开关拨到右边，通过1.5kOhm的电阻对芯片放电，这里的1.5kOhm电阻模拟的是人体电阻。&lt;/p&gt;

&lt;h3 id=&quot;25-esd测试模型---机器模型mm&quot;&gt;25. ESD测试模型 - 机器模型（MM）&lt;/h3&gt;

&lt;p&gt;另一种模型是机器模型，模拟的是通过机械手或者其他电阻较小的工具触碰芯片时发生静电释放的情形。它的模型与人体模型的区别在于电容更大、没有电阻，因此可想而知放电电流会大得多，而且由于导线的电感效应还会出现震荡电流，即对芯片放电的电流是正负变化的。&lt;/p&gt;

&lt;h3 id=&quot;26-esd测试模型---元件充电模型cdm&quot;&gt;26. ESD测试模型 - 元件充电模型（CDM）&lt;/h3&gt;

&lt;p&gt;前两种模型模拟的都是带电体向芯片放电的情况，元件充电模型则模拟的是芯片自身带电，向地放电的情形，从在仓库存放了一段时间的包装里把芯片拿出来时会发生这种现象。这种情况下没有电阻、电容，而是芯片通过管脚直接对地放电，如右图所示。&lt;/p&gt;

&lt;h3 id=&quot;27-esd测试方法&quot;&gt;27. ESD测试方法&lt;/h3&gt;

&lt;p&gt;在测试时涉及到4种放电组合：电源对地、Pin对电源、Pin对地和Pin对Pin，这里我放了其中的两种示意。&lt;/p&gt;

&lt;p&gt;在测电源对地时，先把所有的地接在一起，连到测试电路的地上，其他管脚浮空，然后对要测试的电源管脚打正、负电压，测试时逐步抬高电压值，看能否达到要求。&lt;/p&gt;

&lt;p&gt;而在测试Pin对Pin时，会把电源地浮空，把除了待测Pin以外的Pin接测试电路的地，再对待测Pin打ESD脉冲。&lt;/p&gt;

&lt;h3 id=&quot;28-放电电流&quot;&gt;28. 放电电流&lt;/h3&gt;

&lt;p&gt;如果我们对比一下三种模型下的放电电流波形，就会发现人体模型由于存在电阻，放电会温和很多，CDM的幅度较大，能达到人体模型放电电流大小的40倍，但持续时间很短，是纳秒级的。&lt;/p&gt;

&lt;h3 id=&quot;29-esd测试规格&quot;&gt;29. ESD测试规格&lt;/h3&gt;

&lt;p&gt;对于不同的模型有不同的规格，一般人体模型要容忍2kV，机器模型要容忍200V，元件充电模型要容忍250V才算及格。&lt;/p&gt;

&lt;h3 id=&quot;30-总结&quot;&gt;30. 总结&lt;/h3&gt;

&lt;p&gt;最后总结一下，前面介绍了可靠性、ESD的原理和测试方法。可靠性问题来自于热载流子注入、负偏压温度不稳定性、经时击穿等效应对器件性能的退化和破坏，测试时通过在高温高压下进行来缩短测试时间。ESD会直接对器件造成破坏，需要保护电路来旁路分流掉放电电流以避免损耗内部电路，测试时有人体模型、机器模型、元件充电模型等模型。&lt;/p&gt;

&lt;h3 id=&quot;31-问答&quot;&gt;31. 问答&lt;/h3&gt;

&lt;p&gt;以上就是全部内容，大家有什么要问的吗？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;后记：&lt;/p&gt;

  &lt;p&gt;可靠性和ESD是学生在学校做项目时很少会考虑的事情，即使是在公司做项目也不会是设计时关注的重点，只要最后能过rule就可以了。除非因为ESD器件拖累了速度，需要跟ESD负责人做一些讨价还价。拿这部分作为在暑期夏令营的分享本身就不太合适，奈何之前就有这部分，我也就只能在其基础上按照我的思路补充完善一下去讲。此外之前的分享中还有关于Converter的部分，但是由于我没深入做过相关内容，担心到时候露怯，就没作为今年分享的主题。&lt;/p&gt;

  &lt;p&gt;本来打算过几天去西安的，但是疫情又有了反复，限制了跨省流动，讲座就改成了线上。唉……我的凉皮、米皮、肉夹馍、羊肉泡馍……&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 01 Aug 2021 18:06:28 +0000</pubDate>
        <link>http://localhost:4000/2021/08/01/Reliability_and_ESD_Introduction/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/08/01/Reliability_and_ESD_Introduction/</guid>
        
        <category>Training</category>
        
        <category>ESD</category>
        
        <category>Realibility</category>
        
        
      </item>
    
      <item>
        <title>消费电子中SerDes的发展趋势和关键技术</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;MediaTek再一次在东南大学和西安电子科技大学举办了暑期夏令营，今年的模拟IC部分由我来讲（之前的讲师没时间），PPT因为信息安全问题拿不出来，我就把讲稿整理了一下形成本文。&lt;/p&gt;

  &lt;p&gt;这是第一部分的讲稿，第二部分是&lt;a href=&quot;/2021/08/01/Reliability_and_ESD_Introduction/&quot;&gt;可靠性与ESD介绍&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;1-标题&quot;&gt;1. 标题&lt;/h3&gt;

&lt;p&gt;大家好，欢迎各位同学参加暑期夏令营，在经过了几天Hardware、Software和Digital相关的学习后，今天我们换点不一样的，由我来给大家分享一下Analog部分。&lt;/p&gt;

&lt;p&gt;我的题目是《消费电子中SerDes的发展趋势和关键技术》，提到“SerDes”大家可能或多或少地听说过，我希望通过本次分享可以一方面让大家更清晰地认识到SerDes是个什么东西，有哪些产品用的是SerDes技术，以及SerDes的发展趋势是怎样的。另一方面，考虑到同学们大多是Hardware和Digital背景，我会尽量讲一些浅显的、基础的内容，让大家对Analog的工作内容有个认识，明白Analog Designer所面临的困难和对应的解决方案是怎样的，理解为什么看起来很简单的东西Analog需要费那么大的劲去做。&lt;/p&gt;

&lt;h3 id=&quot;2-自我介绍&quot;&gt;2. 自我介绍&lt;/h3&gt;

&lt;p&gt;先做个自我介绍。我叫马昭鑫，来自合肥分公司模拟部门。2013年从中国科大硕士毕业后，先是到了海思的射频部门，给短距和手机的射频芯片做锁相环。三年半后回到合肥加入了联发科技，现在主要给SerDes做锁相环和时钟恢复。虽说以前做射频，现在做模拟，但其实二者的界限没有很明显，毕竟现在SerDes的工作频率不比射频低了。&lt;/p&gt;

&lt;h3 id=&quot;3-课程安排&quot;&gt;3. 课程安排&lt;/h3&gt;

&lt;p&gt;接下来我会用大约一个小时的时间给大家分享一下我对SerDes的理解。&lt;/p&gt;

&lt;h3 id=&quot;4-大纲&quot;&gt;4. 大纲&lt;/h3&gt;

&lt;p&gt;首先我会介绍一下什么是SerDes，然后带大家认识一下生活中可以见到的SerDes应用，再对其中我觉得比较重要的几项技术做一下分享，如果有什么问题可以在最后的Q&amp;amp;A环节提问。&lt;/p&gt;

&lt;h3 id=&quot;5-什么是serdes&quot;&gt;5. 什么是SerDes&lt;/h3&gt;

&lt;p&gt;“SerDes”是一个合成词，表示“Serializer”和“Deserialzier”，即并转串和串转并，所以我们一般写的时候会把字母D大写。它的功能就像这幅动图表示的一样，发送端把并行的数据先转成串行，再通过信道发送；接收端在接收到数据后再转成并行格式，完成收发动作，就这么“简单”。&lt;/p&gt;

&lt;p&gt;可能有人会问了：“先把并行的转成串行的，再把串行的转回并行的，这是吃饱了撑得吗？”当然不是，通过串行的方式发送数据主要有这么几个好处。&lt;/p&gt;

&lt;h3 id=&quot;6-为什么需要串行接口&quot;&gt;6. 为什么需要串行接口&lt;/h3&gt;

&lt;p&gt;首先来看最左边的这张图。这是PCB上的走线，为什么上面有很多弯弯绕绕的线？这是因为对于并行信号，我们要尽量保证每条信号的延时是相同的，这样才方便接收端接收信号，所以要走“等长线”。很显然这会增加PCB的走线复杂度，并且当频率高到一定程度时，线与线之间的失配会让准确接收信号变成不可能的事。而走串行信号就没这个困扰，一般只要走一对差分线就好。&lt;/p&gt;

&lt;p&gt;其次是Pin的数量和成本。这是显而易见的事情，并行接口要用10个Pin，串行信号只需要2个，多8个Pin不仅是封装成本变高，在PCB上也需要更大的走线空间。更重要的是封装上可用Pin数量的增长速度远远比不上带宽需求的增长速度，后面我们会看到一些数据。&lt;/p&gt;

&lt;p&gt;然后是功率效率，我们用每发送1bit信号所需要的能量评价。串行接口的效率远远好于并行接口，尤其是在通信速率较高的时候，稍后我们也会看到一些数据。&lt;/p&gt;

&lt;p&gt;最后是电磁干扰，这在手机这类集成度非常高的系统中很重要。因为并行接口的信号幅度通常是轨到轨的，比如说0到1.8V；而串行接口的信号幅度可以比较小，比如说0.4V。信号幅度越小，对其他模块的干扰通常也会越小，并且差分信号接口又可以抑制共模干扰，这样在工作时既不会干扰别人，又不怕别人干扰。&lt;/p&gt;

&lt;h3 id=&quot;7-为什么需要串行接口续&quot;&gt;7. 为什么需要串行接口（续）&lt;/h3&gt;

&lt;p&gt;这里补充两组数据。左边的图是IO带宽和Pin的数量逐年变化的情况，很明显Pin的数量增长速度还不够快，毕竟这是受限于尺寸和密度的，而人们对带宽的需求增长得很快，相信大家这几年应该能感受得到。&lt;/p&gt;

&lt;p&gt;右边的图横轴是每根Pin的数据率，黑色的是并行接口的功率效率，蓝色的是串行接口的。采用串行接口可以节省更多的功耗，这对于手机这类使用电池的移动设备来说有重要意义。其实对于大型机房里的设备来说这点也很重要，要知道机房的成本很大一部分是空调费，也就是用在了散热上。&lt;/p&gt;

&lt;h3 id=&quot;8-大纲&quot;&gt;8. 大纲&lt;/h3&gt;

&lt;p&gt;通过前面的内容，我们知道了什么是SerDes以及为什么要用SerDes，接下来让我们看看SerDes在哪些方面有着应用。&lt;/p&gt;

&lt;h3 id=&quot;9-在哪可以找到serdes&quot;&gt;9. 在哪可以找到SerDes&lt;/h3&gt;

&lt;p&gt;以这样一个家庭住址为例，我们从中可以看到哪些应用了SerDes的东西呢？（等10秒）&lt;/p&gt;

&lt;h3 id=&quot;10-在哪可以找到serdes续&quot;&gt;10. 在哪可以找到SerDes（续）&lt;/h3&gt;

&lt;p&gt;圈中的这些都是，比如摄像头、耳机、手机、智能音箱、电视、显示器、汽车等等。&lt;/p&gt;

&lt;h3 id=&quot;11-在哪可以找到serdes续&quot;&gt;11. 在哪可以找到SerDes（续）&lt;/h3&gt;

&lt;p&gt;可以说SerDes是无处不在的。接下来我会举两个例子详细说明一下。&lt;/p&gt;

&lt;h3 id=&quot;12-智能手机中的serdes&quot;&gt;12. 智能手机中的SerDes&lt;/h3&gt;

&lt;p&gt;首先从我们平时使用频率最高的手机说起。这是首发天玑1200的Realme手机，我们从它的规格可以看出商家和用户最关注的地方——好的屏幕、强劲的处理器、多颗高像素摄像头和大容量电池。&lt;em&gt;这款手机的性价比还是很高的，这么高的配置好像只要1600块钱就能买到，需要换机的同学可以考虑一下。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;大家知道手机在摄像、拍照时数据要从摄像头传递到处理器，经过处理后再传到屏幕上进行显示，那么这条信号链路所需要的带宽有多少？1Gbps？10Gbps？我们试着来算一下。以2k屏幕来算，像素点数是1080*2040，色彩空间是8*3，再乘上刷新率120，再考虑到编码效率，最后得到的结果是——8Gbps。当然这个计算方法并不准确，因为没考虑到颜色格式和帧格式，只是让大家对数据率有个印象。要注意到这只是处理器到屏幕的数据量，这款手机还有3颗摄像头呢，可以想象处理器同一时间的数据吞吐量有多大、对IO带宽的需求有多大。&lt;/p&gt;

&lt;h3 id=&quot;13-智能手机中的serdes续&quot;&gt;13. 智能手机中的SerDes（续）&lt;/h3&gt;

&lt;p&gt;除了屏幕和摄像头，手机中还有很多SerDes接口，以MIPI联盟的这张图为例，我们从中可以看到用于存储的UFS接口、用于连接Modem的PCIe接口、用于连接RFIC的DigRF接口等。此外还有图中没显示的用于Memory的DDR接口，虽然这是个并行接口，但技术上其实与SerDes有很多共同之处。&lt;/p&gt;

&lt;p&gt;我们从这些接口的应用中可以看出对SerDes的需求——数据率要高、功耗要小。&lt;/p&gt;

&lt;h3 id=&quot;14-电视中的serdes&quot;&gt;14. 电视中的SerDes&lt;/h3&gt;

&lt;p&gt;接下来让我们看一下另一个生活中比较常见的电子产品——电视。不知道大家有没有发觉，近几年电视的发展速度非常快，面板尺寸从原来的30多吋变成了60多吋，大家去京东、淘宝搜“电视”，会发现卖得最好的是55~65吋这个区间。更大尺寸的也在慢慢普及，比如80多吋。小米前些年甚至出了98吋的电视，荣耀最近好像也出了一款——这个尺寸放家里其实已经非常夸张了。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;我记得之前发生过这么一件事，有个用户买了台98吋的电视，结果送货的时候发现居然连电梯都放不进去，最后是拿吊车给从阳台上吊进去的。雷军就发了条微博说谁买了这台电视，全小区都会认识你。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;面板尺寸大了分辨率一定要高，否则离近了一看全是马赛克，所以4k、8k开始普及了。然后刷新率也要高，否则在小屏幕上看起来很平滑的移动，在大屏幕上因为移动的距离变远了看起来就会很不自然。即使信号源的帧率没那么高，电视自己也要插值把帧率提上去。还有其他功能也要跟上，色彩空间、HDR、3D等等……&lt;/p&gt;

&lt;h3 id=&quot;15-电视中的serdes续&quot;&gt;15. 电视中的SerDes（续）&lt;/h3&gt;

&lt;p&gt;我们来看这个框图，信号源通过线缆把信号发到电视的处理器上，处理完后再把信号发到面板上，画面才能显示出来。其中就会用到HDMI和VBO两个SerDes接口，从之前算手机的带宽需求也不难看出，电视所需要的带宽更大，比如HDMI 2.1已经可以支持到48Gbps的数据率。&lt;/p&gt;

&lt;p&gt;电视相对手机还有个特点——大，或者说是信号路径长。手机最多也就十几厘米，而HDMI线有两三米长，面板上的走线也有一两米，这对SerDes的要求是——不仅要传得快，还要传得远。&lt;em&gt;MediaTek现在做的HDMI 2.1接口可以支持5米长的线，这有什么好处？这样就可以用投影了仪，因为投影仪通常要放到客厅的另一面墙那嘛。&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;16-serdes标准&quot;&gt;16. SerDes标准&lt;/h3&gt;

&lt;p&gt;好了，我们不再一一举例，直接来看这幅图：横轴是时间，纵轴是数据率，不同颜色的点是不同的协议标准。从中我们可以看到很多熟悉的标准：比如攒机的同学会非常熟悉的PCIe接口，一般用来接显卡，现在也会用来接固态硬盘什么的；比如USB，现在几乎一统天下了，传数据、充电都可以用；还有显示器上都会有的DP接口等等。从这张图上不难看出，各SerDes标准的数据率越来越高，呈指数级增长，这就为我们的电路设计提出了很大的挑战。&lt;/p&gt;

&lt;h3 id=&quot;17-大纲&quot;&gt;17. 大纲&lt;/h3&gt;

&lt;p&gt;接下来就让我们看一下困难点在哪，以及如何应对。&lt;/p&gt;

&lt;h3 id=&quot;18-框图&quot;&gt;18. 框图&lt;/h3&gt;

&lt;p&gt;让我们再深入地看一下SerDes，发送端包括并转串电路和驱动器，二者在锁相环提供的时钟驱动下把数据送到信道中，接收端会先做均衡——等下我会解释这是什么——然后进行采样，最后经过串转并电路恢复成原数据，在接收端会有时钟恢复模块自动寻找最佳的采样时刻，就像右下角的时序图示意的那样。&lt;/p&gt;

&lt;h3 id=&quot;19-典型场景&quot;&gt;19. 典型场景&lt;/h3&gt;

&lt;p&gt;在实际应用中，无论中间是线缆还是PCB走线，信号一定是从一颗芯片经过封装、PCB走线等一系列路径走到另一颗芯片里面，这条路径上会产生损耗、反射、串扰等。一个典型的信道的频率响应曲线就如右边的图所示，一般频率越高损耗越大，实际的情况还要与路径的长短、材质有关。信号经过这条路径后会发生一定的畸变。&lt;/p&gt;

&lt;h3 id=&quot;20-波形&quot;&gt;20. 波形&lt;/h3&gt;

&lt;p&gt;一个这样的波形从发射端出来，经过前面那样的信道会变成什么样子呢？我们可以想到高频部分被衰减、低频部分会被保留，一组方波信号到了接收端就会变成这样子……感受一下，这个可能跟做数字电路的同学的认知不太一样，但真实的波形就是这样，不能说面目全非吧，但已经被磨平了棱角，看不太出来原先的信号了。当然这是在衰减比较大的情况下，如果衰减小一些还是能看出来的。那么问题就来了，如何&lt;strong&gt;定量&lt;/strong&gt;地评价信号的质量呢？&lt;/p&gt;

&lt;h3 id=&quot;21-眼图&quot;&gt;21. 眼图&lt;/h3&gt;

&lt;p&gt;我们引入“眼图”这个概念。眼图的获取方式很简单，先采集到波形，然后把波形分成小份，再叠加在一起，就会得到右上角的这幅图。这幅图的中间好像是一只眼睛，因此称作“眼图”。眼的大小决定了采样时的裕度，我们希望眼越大越好。&lt;/p&gt;

&lt;p&gt;定量的说就是眼高和眼宽，眼宽大小意味着采样的时候对时钟位置的要求高低，眼高大小意味着对比较器容限的要求高低，翻译成更直白的话就是：眼越大采样的时候就越不容易出错。SerDes协议在制定标准时会把眼图作为很重要的一个兼容测试项。&lt;/p&gt;

&lt;p&gt;让我们仔细地看一下这幅眼图，因为后面会频繁地用到。你会发现它是由很多条线组成的，这一幅图里包含了2个单位间隔、3个bit值、8种可能的组合，决定眼大小的是101和010两个组合，不过这个并不绝对，可能有的场景是其他的组合限制了。&lt;/p&gt;

&lt;h3 id=&quot;22-信道损耗&quot;&gt;22. 信道损耗&lt;/h3&gt;

&lt;p&gt;好了，我们回顾一下，免得出现那种&lt;em&gt;低头捡了只笔，结果这门课就再也没听懂过&lt;/em&gt;的情况发生。&lt;/p&gt;

&lt;p&gt;我们知道了SerDes通信归根到底是两颗芯片里面的电路通过一系列路径，也就是信道，收发信号的过程。波形通过信道后会发生畸变，畸变的程度可以通过眼图里眼的大小进行判断，只有眼睛睁开才能正确地接收到信号，眼睛越大抗干扰能力就越强，而信道的衰减越大眼睛就闭合的越厉害。&lt;/p&gt;

&lt;p&gt;比如这两幅图，一个是2Gbps，信道衰减大约是6dB，另一个是5Gbps，信道衰减大约是12dB，两个眼图就会差这么多。现在思考一下，为什么会这样？&lt;/p&gt;

&lt;h3 id=&quot;23-码间干扰&quot;&gt;23. 码间干扰&lt;/h3&gt;

&lt;p&gt;让我们引入码间干扰的概念。傅里叶变换告诉我们，时域与频域存在着对偶性，时域越窄对应的频域越宽，而频域越窄对应的时域就会越宽。当一个窄脉冲信号通过有限带宽的信道后会被展宽，就像左边这张图所表示的。而对于一个线性时不变系统，一系列信号经过系统后的输出，与信号一部分一部分地通过系统再叠加在一起的效果是一样的。我们来看一下右边这幅图，发送端送出来的信号是101，前面的1产生的响应是红色的线，后面的1产生的响应是蓝色的线，二者相加是黑色的线。当用中间电平作为阈值去判别数据时会发现中间这个0就被误判成了1，产生了误码。这就叫码间干扰，总结一下就是前一bit残留的状态影响了后续的bit。&lt;/p&gt;

&lt;h3 id=&quot;24-均衡&quot;&gt;24. 均衡&lt;/h3&gt;

&lt;p&gt;我们知道了码间干扰是造成眼图闭合的直接原因，而根本原因是信道衰减导致的有限带宽。那么如何解决这个问题呢？&lt;/p&gt;

&lt;p&gt;一般来说走线越长衰减越厉害，那走短点线或者用一些好材质的线能不能解决问题？能，但是很难实现，因为客户的需求我们是改变不了的。&lt;/p&gt;

&lt;p&gt;那因为带宽太窄才会造成这个问题，如果我们想个办法让带宽变宽点行不行？行！怎么做？我们可以做一个滤波器，串在信道上，让滤波器的频率响应正好跟信道本身的响应相反，抑制低频、增强高频，使得整体的带宽是宽的。这样就可以改善码间干扰，让眼图张开。&lt;/p&gt;

&lt;p&gt;那直接从码间干扰下手行不行？也行。因为我们可以想办法得到信道引起的码间干扰，当接收到一个信号后便可以知道它对后续的bit会产生什么样的影响，我们直接把这个影响减掉就可以了。&lt;/p&gt;

&lt;p&gt;这两种方法都称作“均衡”。&lt;/p&gt;

&lt;h3 id=&quot;25-均衡续&quot;&gt;25. 均衡（续）&lt;/h3&gt;

&lt;p&gt;均衡可以做在发射端，也可以做在接收端。常见的方法如图所示：在发射端做的是前馈均衡器FFE，按照实现方式又有预加重和去加重两种；在接收端做的有连续时间线性均衡器CTLE和判决反馈均衡器DFE，现在有的也会在接收端加个FFE进一步增强均衡效果。接下来我们逐一看一下。&lt;/p&gt;

&lt;h3 id=&quot;26-均衡---ffe&quot;&gt;26. 均衡 - FFE&lt;/h3&gt;

&lt;p&gt;前馈均衡器FFE的实现方式非常简单，如左图所示，这是一个3阶有限冲击响应滤波器，它的输出如中图所示，右图所示的是原先的眼图和使用均衡器后的眼图的对比。从中图不难看出，在信号跳变时波形会先往反方向跳一下，以增大跳变的幅度。&lt;em&gt;打个比方，如果你想把一根有弹性的铁丝弯成90度需要怎么做？会先把它弯得比90度更厉害，然后松手让它自己回弹到90度的位置。FFE的做法是类似的，既然信道会把边沿变得平缓，那么我就把边沿变得更加陡峭，这样经过信道后仍然可以保持原有的样子。&lt;/em&gt;如果从频域或者码间干扰的角度看，就是前面（第24页）右图的样子，这个滤波器的频率响应是红色的线，信道的频率响应是蓝色的线，二者叠加就成了绿色的线，显然叠加后的带宽被大大增加了，码间干扰也会大大减小。&lt;/p&gt;

&lt;p&gt;这种结构的优点是简单，只需要对信号做延时，然后乘以相应的系数后加在一起就可以了，在模拟电路上乘不同的系数就是驱动不同大小的电流，相加就是直接把输出接在一起，非常容易实现。但是它的缺点是会减小低频的增益，我们从波形也很容易看出，发送长0或长1时输出幅度只有这么大；观察眼图也可以看出来，原先有0.8V的幅度，现在只有0.2V了。这种保持最大幅度、减小长0长1幅度的做法称作“去加重”。如果是保持长0长1的幅度、在信号跳变时额外增加波形幅度的做法称作“预加重”，这种做法虽然不会降低低频处的幅度，但是会给可靠性带来压力，下次分享我会讲到原因。&lt;/p&gt;

&lt;h3 id=&quot;27-均衡---ffe续&quot;&gt;27. 均衡 - FFE（续）&lt;/h3&gt;

&lt;p&gt;在近几年MediaTek发表的ISSCC中一直采用左图所示的FFE，因为它的驱动器是DAC结构的，所以可以直接用数字电路实现FFE。从右图的对比表格可以看到现在高性能的SerDes普遍会使用3~4阶的FFE。&lt;/p&gt;

&lt;p&gt;另外大家注意一下，这部分电路的工作频率是多少？工作频率就是数据率，一般是5GHz以上，对于论文中的这些SerDes会达到50GHz、100GHz。&lt;em&gt;有不少同学是做Digital的，你能想象一块数字电路的工作频率是上百GHz吗？这一定需要非常先进的工艺支持，也就是很多人说的“SerDes非常吃工艺”。所以各位同学如果想做一些高性能的东西，一定要选好平台，比如MediaTek这种，否则空有想法实现不了。&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;28-均衡---ctle&quot;&gt;28. 均衡 - CTLE&lt;/h3&gt;

&lt;p&gt;让我们再来看连续时间均衡器CTLE，它的思路同样是在信道上串一个增强高频增益的滤波器，与前面FFE的区别在于它是工作在连续时间域的。一种典型的实现方式如左图所示，源端的电阻电容构成零点，抬高了高频处的增益。右图即为使用CTLE前后的眼图对比，注意看眼图高低与FFE的区别，CTLE的更高，这是因为它能提供一定的增益。CTLE的缺点是它在放大信号的同时也会放大噪声，另外因为零点的位置是由电阻电容决定的，而电阻电容是会随着工艺偏差变化的，就会导致补偿的效果像中图一样发生改变，在实际应用中还需要进行矫正。&lt;/p&gt;

&lt;h3 id=&quot;29-均衡---ctle续&quot;&gt;29. 均衡 - CTLE（续）&lt;/h3&gt;

&lt;p&gt;这是MediaTek在去年和今年发表的ISSCC，可以看到不仅放了CTLE，还放了可变增益放大器VGA来进一步抵消损耗的影响。因为它是用ADC做采样器，因此还可以在数字域用FFE进一步增大高频增益，从对比表格里也可以看到这是100Gbps高速SerDes的主流做法。而今年发的ISSCC中提到的CTLE的做法比较有趣，我就把它贴了出来，它不是采用前面我们提到的源级反馈放大器结构，而是利用延时相减的结构。它们本质的原理是一样的，目的都是要增大高频增益，算得上是一种“条条大路通罗马”，感兴趣的同学可以去看一下这篇论文，这里就不展开讲了。&lt;/p&gt;

&lt;h3 id=&quot;30-均衡---dfe&quot;&gt;30. 均衡 - DFE&lt;/h3&gt;

&lt;p&gt;接下来是判决反馈均衡器DFE，它与前两个的区别在于这不是一个线性均衡器，它的原理是假设我已经得到了当前信号，并推断出这个信号会引入的码间干扰，那么就可以在接下来的过程中减掉它所引入的码间干扰，这样就直接拉开了眼图。它的实现方式就如左图所示，把采样得到的信号通过滤波器反馈回来，如果滤波器的频率响应与信道相当，那么它们引入的码间干扰会直接抵消掉。中图是脉冲响应，原本的响应曲线是这样的，使用了DFE后可以把后两个采样时刻的码间干扰直接拉成0，所以在看眼图是可以看到在中间会跳一下。&lt;/p&gt;

&lt;p&gt;这种均衡器的优点是不会放大噪声，但也有很明显的缺点，大家能看出来吗？判据反馈均衡器必须要在判决后才能施加影响，那么对于判决前的码间干扰是无能为力的。另外它也会让相位检测变得复杂，而相位检测是做时钟恢复的基础，等下我们会讲到。&lt;em&gt;如果说通过学习这种均衡器的原理能给我带来一些启发的话，我想是做模拟的也要了解一些数字的知识，做数字的也可以在模拟领域找到自己的应用。尤其是当集成电路设计发展了这么多年，很多问题需要模拟和数字共同合作才能解决。&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;31-均衡---dfe续&quot;&gt;31. 均衡 - DFE（续）&lt;/h3&gt;

&lt;p&gt;让我们看一下发表的论文，1~3阶的DFE都有应用。今年有篇ISSCC的做法跟以往不太一样，它是通过两条路径相加去实现的，乍一看跟FFE有点像。但仔细看就会发现它的本质仍然是把采样后的结果拿回来去跟原来的信号做运算，原理是一样的，只是换了种做法。&lt;/p&gt;

&lt;p&gt;好了，我们小结一下，前面一共提到了3种均衡方法，前两种是通过往信道里串滤波器的方法展宽总体的带宽，最后一种是直接从码间干扰下手，前两种的区别是FFE是离散时间域的，CTLE是连续时间域的。&lt;/p&gt;

&lt;p&gt;如果在使出这三种均衡技术后眼图还是不够好怎么办？&lt;em&gt;跟客户说做不了？不好吧，最多可以跟客户说这个不好做，&lt;strong&gt;得加钱&lt;/strong&gt;！&lt;/em&gt;我们前面看信道的频率响应曲线时有看到频率越高衰减越厉害，那么能不能在保持数据率不变的前提下减小信号的频率？&lt;/p&gt;

&lt;h3 id=&quot;32-pam-4&quot;&gt;32. PAM-4&lt;/h3&gt;

&lt;p&gt;之前的码型我们称之为非归零码NRZ，它是取整个电压范围的最大和最小两个档位来标记数据，我们还可以称之为PAM-2，这里的“PAM”是脉冲幅度调制的意思。PAM-2每个符号能发送1bit信息。如果我们把电压范围分细一点，分出来4个档位，那么每个符号就可以发送2bit信息了，这就叫PAM-4。由于PAM-4每个符号可以携带两倍的信息，那么在数据率不变的情况下可以减半信号频率。&lt;/p&gt;

&lt;p&gt;采用这种码型除了接收端至少需要用3个比较器来判决信号外，眼高会变成原先的1/3，真的能改善眼图吗？&lt;/p&gt;

&lt;h3 id=&quot;33-眼图对比&quot;&gt;33. 眼图对比&lt;/h3&gt;

&lt;p&gt;这不一定。这页PPT所示的是两种不同的信道下，使用NRZ和PAM-4时的眼图对比。可见在衰减较大时PAM-4才能展现出相对NRZ的优势。目前消费电子里PCIe Gen6才会用到PAM-4，到时候的工作频率会达到64GHz，其他的标准还没跟进这么快。但是应用PAM-4应该是早晚的事，毕竟铜介质的物理特性就在那里，只要数据率不断提升，迟早需要用到PAM-4。&lt;/p&gt;

&lt;p&gt;前面我们讲的内容都是基于发送的信号是理想的情况下进行的，但现实中还会有其他因素导致眼的压缩，接下来我们介绍影响眼宽的重要因素——抖动。&lt;/p&gt;

&lt;h3 id=&quot;34-抖动&quot;&gt;34. 抖动&lt;/h3&gt;

&lt;p&gt;前面介绍时我们认为波形跳变的时刻是理想的、均匀的，但可惜实际上驱动电路工作的时钟存在着抖动。抖动的意思是时钟的沿出现的位置相对于理想位置会有偏差，可能会早一点出现，也可能会晚一点出现。这点做数字的同学应该比较熟悉了，你在算建立保持时间时就要考虑到抖动带来的影响。对于SerDes来说是相似的，时钟决定了波形跳变的时刻，如果时钟出现晃动那么波形的跳变位置也会跟着晃动，体现在眼图上就是眼宽被压缩了。&lt;/p&gt;

&lt;p&gt;我们把眼图从中间横着切一刀，把信号与这一刀的交点用直方图的方式画出来就得到了这一个图，据此可以进行一些分析。&lt;/p&gt;

&lt;h3 id=&quot;35-抖动续&quot;&gt;35. 抖动（续）&lt;/h3&gt;

&lt;p&gt;抖动有很多产生原因，有的与发送的数据相关，比如说码间干扰、串扰，而有的是时钟自身带的，比如说随机抖动RJ、正弦抖动SJ等。其中随机抖动比较特殊，一般假设它是由器件的闪烁噪声、热噪声引起的，呈高斯分布，并且是无边界的，即样本数越大随机抖动的范围就越大，所以一般我们讲它的均方根值。在具体到一定误码率时再乘以相应的系数得到峰峰值，比如误码率是1e-12时系数是14.069，就意味着对于1e12个样本，随机抖动引入的抖动范围大约是其均方根值得14.069倍。&lt;/p&gt;

&lt;h3 id=&quot;36-误码率与浴缸曲线&quot;&gt;36. 误码率与浴缸曲线&lt;/h3&gt;

&lt;p&gt;由于眼宽等于单位间隔减去总的抖动TJ，而TJ中RJ的贡献与误码率有关，因此可以得到右边这张图，表示眼宽随着误码率变化的情况。显然相同的RJ下对误码率的要求越高眼宽越小，或者说相同的眼宽下对RJ的要求越高，那么如何提供一个稳定的时钟呢？&lt;/p&gt;

&lt;h3 id=&quot;37-锁相环&quot;&gt;37. 锁相环&lt;/h3&gt;

&lt;p&gt;我们都知道现代的集成电路里都会用到时钟，并且各系统的时钟频率还各不相同，那么怎么产生这些时钟呢？答案就是锁相环，它的原理是输入一个低频时钟，通过环路控制内部的振荡器产生高频时钟，高频时钟是低频时钟的N倍，这个N既可以是整数也可以是小数。低频时钟信号通常来自晶体振荡器，它的频率非常稳定，那么通过调整倍数N即可获得我们想要的时钟频率。&lt;em&gt;不知道有没有同学搞过CPU超频，其中就有步骤去调这个N值。&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;38-锁相环中的噪声贡献&quot;&gt;38. 锁相环中的噪声贡献&lt;/h3&gt;

&lt;p&gt;我们前面提到过集成电路中的器件会贡献噪声，对于锁相环来说不同位置的模块所贡献的噪声是不同的。这张图所表示的就是锁相环的线性模型和噪声源，输入的参考时钟的高频噪声会被环路滤除，低频噪声会被保留和放大；而振荡器的高频噪声会直接输出，低频噪声会被环路抑制。因此为了得到性能最佳的时钟，我们需要合理地选择环路参数，在几个噪声源之间取折中。&lt;/p&gt;

&lt;p&gt;在高速SerDes中留给RJ的空间越来越小，但先进工艺的器件噪声却越来越大，因此高速SerDes中低噪声锁相环的设计是一个难点。这里就不展开讲了，对锁相环感兴趣的同学可以深入地学习一下相关内容。&lt;/p&gt;

&lt;h3 id=&quot;39-展频时钟&quot;&gt;39. 展频时钟&lt;/h3&gt;

&lt;p&gt;前面我们提到过，在手机这种集成度很高又有射频系统的设备中，电磁干扰是一个很麻烦的事情，尤其是现在高速SerDes的速度已经达到了射频范围，因此还需要一定的方式进一步改善电磁干扰。展频时钟的原理是让时钟频率在一定范围内来回改变，相当于把原先集中在一个频点的能量分配到一个频率区间，这样体现出的平均功率密度就会低不少。具体的实现方式就是动态的改变锁相环中的倍频比N，先在数字域实现一个锯齿波发生器，然后通过锁相环的接口动态改变环路分频比，锁相环输出的时钟频率也就会跟着调整了。&lt;/p&gt;

&lt;h3 id=&quot;40-时钟恢复&quot;&gt;40. 时钟恢复&lt;/h3&gt;

&lt;p&gt;前面简单的讲了下发送端的时钟技术，现在再来看一下接收端的。对于接收端来说，需要在合适的位置对信号进行判决，就像图示的那样。但是由于码间干扰、串扰的影响，以及发送端时钟的抖动和故意加上的展频，怎么才能保证判决的位置是合适的呢？&lt;/p&gt;

&lt;h3 id=&quot;41-时钟恢复续&quot;&gt;41. 时钟恢复（续）&lt;/h3&gt;

&lt;p&gt;与锁相环类似，都是用到了锁相技术。在实现上有多种结构，比较常见的是基于锁相环的和基于相位内插的。基于锁相环的原理是通过相位检测器产生的信号调整振荡器的频率，而基于相位内插的是直接调整时钟的相位，二者各有利弊，目前的应用都很广泛。此外还有基于延迟锁相环DLL的、盲采的，甚至还有全数字的结构等等，感兴趣的同学可以深入了解一下，这里就不展开讲了。&lt;/p&gt;

&lt;h3 id=&quot;42-工程事务&quot;&gt;42. 工程事务&lt;/h3&gt;

&lt;p&gt;除了前面提到的这些技术，在工程上还有很多事情需要处理，比如各种矫正算法、高速逻辑电路设计、技术选型、电源划分、可靠性等等。&lt;em&gt;只有这些都做好了，客户才能拿到好用、经用的产品。&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;43-总结&quot;&gt;43. 总结&lt;/h3&gt;

&lt;p&gt;最后做一个总结，在前面的分享中我主要提到了均衡器和时钟产生电路两部分，而在整个SerDes TRx架构中，还有一些高速逻辑、驱动器、Termination等电路，以及矫正算法、协议的控制等数字模块，这里因为时间问题就不多讲了。&lt;/p&gt;

&lt;h3 id=&quot;44-问答环节&quot;&gt;44. 问答环节&lt;/h3&gt;

&lt;p&gt;谢谢各位的听讲，如果有什么问题，请示意我。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;后记：&lt;/p&gt;

  &lt;p&gt;因为现在做Analog的学生不多，其中又有不少是做Power和Converter的，在东南那场中大多数同学都听得一头雾水，如果下次还需要我讲的话，我会把内容往与Digital/Hardware合作的部分靠。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 31 Jul 2021 10:31:25 +0000</pubDate>
        <link>http://localhost:4000/2021/07/31/SerDes_Trends_and_Key_Technologes_In_Consumer_Electronics/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/07/31/SerDes_Trends_and_Key_Technologes_In_Consumer_Electronics/</guid>
        
        <category>Training</category>
        
        <category>SerDes</category>
        
        
      </item>
    
      <item>
        <title>振荡器九宫格</title>
        <description>&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;有选频网络的自激振荡&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;能自激振荡就算&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;有驱动时钟也未尝不可&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;必须要有电压控制&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;LC-VCO&lt;/td&gt;
      &lt;td&gt;Ring VCO&lt;/td&gt;
      &lt;td&gt;VCDL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;数字信号也算控制电压&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;LC-DCO&lt;/td&gt;
      &lt;td&gt;Ring DCO&lt;/td&gt;
      &lt;td&gt;分频器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;没有控制信号也不是不行&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;XO&lt;/td&gt;
      &lt;td&gt;张弛振荡器&lt;/td&gt;
      &lt;td&gt;反相器&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;九宫格&lt;/strong&gt;
 &lt;img src=&quot;/img/in-post/2021-07-04-Nine_Types_Oscillator.assets/nine.jpg&quot; alt=&quot;&quot; /&gt;
之前在网上看到过一篇辨析三明治的文章（应该是fall_ark写的，原文找不到了，&lt;em&gt;weibo的搜索功能真是烂得一塌糊涂&lt;/em&gt;），里面有副类似上图的“九宫格”，可以看到从“结构”和“材料”上逐渐滑坡/叛逆，得到了让人啼笑皆非的结论。后来又看到了很多很多类似的图片，甚至还有人总结整理了一份&lt;a href=&quot;https://zhuanlan.zhihu.com/p/150752061&quot;&gt;三明治模式阵营九宫格节选 - 知乎&lt;/a&gt; ，然后我就想振荡器是不是也可以这么玩？于是就有了本文开头的那个表格……&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 04 Jul 2021 10:31:25 +0000</pubDate>
        <link>http://localhost:4000/2021/07/04/Nine_Types_Oscillator/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/07/04/Nine_Types_Oscillator/</guid>
        
        <category>PLL</category>
        
        
      </item>
    
  </channel>
</rss>
